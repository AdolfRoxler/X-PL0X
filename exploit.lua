--GUI = loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/drawinglib.lua')()
devmode = devmode or true
repeat wait() until Drawing
if getgenv().XPL0X and not devmode then return end
getgenv().XPL0X = true
local WAITBACKGROUND = Drawing.new("Quad")
local WAITMSG = Drawing.new("Text")
local ASSETCOUNT = Drawing.new("Text")
CR1=Drawing.new("Line")
CR2=Drawing.new("Line")
AIMSTATUS=Drawing.new("Text")
AIMSTATUS2=Drawing.new("Text")
PATHSTATUS=Drawing.new("Text")
--- warn(UserSettings():GetService("UserGameSettings").MouseSensitivity) this'll come in handy later.


if game:IsLoaded() then else  ---- In case game didn't load leave out a nice ass message like this
	repeat game:GetService("RunService").RenderStepped:Wait() 
		WAITMSG.Center = true 
		WAITMSG.Visible = true
		WAITMSG.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X/2,workspace.CurrentCamera.ViewportSize.Y/3)
		WAITMSG.Size = workspace.CurrentCamera.ViewportSize.Y/workspace.CurrentCamera.ViewportSize.X/10
		WAITMSG.Text = "Yo nigga the game hasn't loaded yet"
		WAITMSG.Color = Color3.new(1,1,1)
		WAITMSG.OutlineColor = Color3.new(0,0,0)
		WAITMSG.Outline = true
		WAITMSG.Font = 0
		WAITBACKGROUND.Visible = true
		WAITBACKGROUND.PointA = Vector2.new(workspace.CurrentCamera.ViewportSize.X,0)
		WAITBACKGROUND.PointB = Vector2.new(0,0)
		WAITBACKGROUND.PointC = Vector2.new(0,workspace.CurrentCamera.ViewportSize.Y)
		WAITBACKGROUND.PointD = Vector2.new(workspace.CurrentCamera.ViewportSize.X,workspace.CurrentCamera.ViewportSize.Y)
		WAITBACKGROUND.Color = Color3.new(1,1,1)
		WAITBACKGROUND.Transparency = 1
		WAITBACKGROUND.Filled = true
		ASSETCOUNT.Size = WAITMSG.Size*0.8
		ASSETCOUNT.Position = Vector2.new(WAITMSG.Position.X,WAITMSG.Position.Y+WAITMSG.TextBounds.Y)
		ASSETCOUNT.Text = "Brought to you by hicksville (real)"
		ASSETCOUNT.OutlineColor = Color3.new(0,0,0)
		ASSETCOUNT.Color = Color3.new(1,1,1)
		ASSETCOUNT.Center = true
		ASSETCOUNT.Visible = true
		ASSETCOUNT.Outline = true
		ASSETCOUNT.Font = 0
	until game.Loaded
end

function GetBoundingBox(model, recursive, orientation, mustcollide) ----- copypasted code xdflol
	if typeof(model) == "Instance" then
		model = recursive and model:GetDescendants() or model:GetChildren() --- had to modify some shit, last two variables are implemented by me
	end
	if not orientation then
		orientation = CFrame.new()
	end

	local minx, miny, minz = math.huge,math.huge,math.huge
	local maxx, maxy, maxz = -math.huge,-math.huge,-math.huge

	for _, obj in pairs(model) do
		if obj:IsA("BasePart") then
			if mustcollide then if obj.CanCollide then else return end end
			local cf = obj.CFrame
			cf = orientation:toObjectSpace(cf)
			local size = obj.Size
			local sx, sy, sz = size.X, size.Y, size.Z

			local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cf:components()

			local wsx = 0.5 * (math.abs(R00) * sx + math.abs(R01) * sy + math.abs(R02) * sz)
			local wsy = 0.5 * (math.abs(R10) * sx + math.abs(R11) * sy + math.abs(R12) * sz)
			local wsz = 0.5 * (math.abs(R20) * sx + math.abs(R21) * sy + math.abs(R22) * sz)

			if minx > x - wsx then
				minx = x - wsx
			end
			if miny > y - wsy then
				miny = y - wsy
			end
			if minz > z - wsz then
				minz = z - wsz
			end

			if maxx < x + wsx then
				maxx = x + wsx
			end
			if maxy < y + wsy then
				maxy = y + wsy
			end
			if maxz < z + wsz then
				maxz = z + wsz
			end
		end
	end

	local omin, omax = Vector3.new(minx, miny, minz), Vector3.new(maxx, maxy, maxz)
	local omiddle = (omax+omin)/2
	local wCf = orientation - orientation.p + orientation:pointToWorldSpace(omiddle)
	local size = (omax-omin)
	return wCf, size
end

Phys = devmode and loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/dev/libraries/physicsMANIPULATOR.lua')() or loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/physicsMANIPULATOR.lua')()
Gaylib = devmode and loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/dev/libraries/Kavo.lua')() or loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/Kavo.lua')()
math2 = devmode and loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/dev/libraries/arbitrarymath.lua')() or loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/arbitrarymath.lua')()
spoofer = devmode and loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/dev/libraries/metatableMANIPULATOR.lua')() or loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/metatableMANIPULATOR.lua')()
testthumb = game:GetService("Players"):GetUserThumbnailAsync(2408936922,0,6)
Notifications = {}
Notifications.Overwrite = {Title="Configuration overwritten",Text="Settings have been saved",Icon=testthumb,Duration=4}
Notifications.Read = {Title="Configuration read",Text="Settings have been loaded",Icon=testthumb,Duration=4}

repeat wait() until game:GetService('Players').LocalPlayer
repeat wait() until workspace.CurrentCamera
WAITBACKGROUND:Remove()
WAITMSG:Remove()
ASSETCOUNT:Remove()
User = game:GetService('Players').LocalPlayer
Mouse = User:GetMouse()
UserChar,UserHum,hr=nil
SUPERMANN=nil
Rig=nil
inset = 36
SUPERMAN = Instance.new("Animation")
SUPERMAN.AnimationId="http://www.roblox.com/asset/?id=616115533"  ---superman animation???? god muddafuggin dam!!!!
SUPERMANR6 = Instance.new("Animation")
SUPERMANR6.AnimationId = "rbxassetid://429681631"  ---superman animation for r6???? god muddafuggin dam!!!!
function changestatus(h) --- I guess this is how I'll set up humanoid status changes from now on
	if Config.IMMORTALITY==true and h then h:SetStateEnabled(15,false) end --my dumb ass thought this was somewhere else
	if Config.SWIM==true and h then h:ChangeState(4) end
	if Config.flight==true and h then h:ChangeState(5) end
	if Config.FIDGETSPINNER==true and h then h:ChangeState(8) end
end
function XRAY(int)
local int = tonumber(int) or 0
local function search(obj)
if obj:IsA("BasePart") then obj.LocalTransparencyModifier = math.abs(int) end
if obj:FindFirstChildOfClass("Humanoid") then return end
for _,l in pairs (obj:GetChildren()) do
search(l)
end
end
search(workspace)
end

function charinstanceaddedfunc(l,h)
if (Config.AFELOOP or Config.FIDGETSPINNER) and l and l:IsA("Tool") and h then
game:GetService("RunService").Stepped:Wait()
UserHum:UnequipTools()
end
end

AllocatedPath = game:GetService("PathfindingService"):CreatePath({AgentRadius=0,AgentHeight=0,AgentCanJump = true}) --- The 'weird first two parameters' are necessary in this case.
Waypoints = {}
PathState = nil

function findpath(From,To,Path,overwritemaintable)
local from = From
local to = To
local path = Path
if from and to and path then else return nil end
if typeof(from) == "CFrame" then from = from.p end
if typeof(to) == "CFrame" then to = to.p end
    local success,eror = pcall(function()
	path:ComputeAsync(from,to) end)
    if not success then return nil end
	if overwritemaintable then PathState = path.Status Waypoints = path:GetWaypoints() else return path.Status,path:GetWaypoints() end--return nil,tostring(errorMessage) 
end


if UserChar and UserHum and hr and UserHead then else
	if humanoidstatuschanger then humanoidstatuschanger:Disconnect() end
    if CharInstanceAddedFunc then CharInstanceAddedFunc:Disconnect() end
    if tpfixer then tpfixer:Disconnect() end
	spawn(function()
		repeat wait() until User.Character
		UserChar = User.Character
        if UserChar:FindFirstChild("Head") and UserChar:FindFirstChild("Head"):IsA("BasePart") then UserHead = UserChar:FindFirstChild("Head") end
        CharInstanceAddedFunc = UserChar.ChildAdded:connect(function(s) charinstanceaddedfunc(s,UserHum) end)
		if UserChar:FindFirstChildOfClass("Humanoid") then UserHum=UserChar:FindFirstChildOfClass("Humanoid") hr = UserHum.RootPart Rig = UserHum.RigType humanoidstatuschanger = UserHum.StateChanged:connect(function() changestatus(UserHum) end) tpfixer = UserHum.Changed:connect(function(b) if b=="Sitting" and teleportingtowardspoint then UserHum.Sitting = false end end) end
		spawn(function() while UserHum==nil do wait() end
			if UserHum and UserHum.RigType == Enum.HumanoidRigType.R15 then
				SUPERMANN = UserHum:LoadAnimation(SUPERMAN) SUPERMANN.Priority = Enum.AnimationPriority.Action SUPERMANN.TimePosition = 1 SUPERMANN.Looped = true
			elseif UserHum then
				SUPERMANN = UserHum:LoadAnimation(SUPERMANR6) SUPERMANN.Priority = Enum.AnimationPriority.Action SUPERMANN.TimePosition = .09 SUPERMANN.Looped = true
			end
			changestatus(UserHum)
		end)
	end)
end

User.CharacterAdded:connect(function(nig)
	if humanoidstatuschanger then humanoidstatuschanger:Disconnect() end
    if CharInstanceAddedFunc then CharInstanceAddedFunc:Disconnect() end
    if tpfixer then tpfixer:Disconnect() end
	UserChar = nig
    CharInstanceAddedFunc = UserChar.ChildAdded:connect(function(s) charinstanceaddedfunc(s,UserHum) end)
	SUPERMANN = nil
	UserHum=UserChar:FindFirstChildOfClass("Humanoid")
    if UserChar:FindFirstChild("Head") and UserChar:FindFirstChild("Head"):IsA("BasePart") then UserHead = UserChar:FindFirstChild("Head") end
	spawn(function()
		repeat wait() until User.Character and User.Character:FindFirstChildOfClass("Humanoid")
		UserHum=UserChar:FindFirstChildOfClass("Humanoid") 
        hr = UserHum.RootPart
		humanoidstatuschanger = UserHum.StateChanged:connect(function() changestatus(UserHum) end)
		tpfixer = UserHum.Changed:connect(function(b) if b=="Sitting" and teleportingtowardspoint then UserHum.Sitting = false end end)
		Rig = UserHum.RigType
		if User.Character:FindFirstChildOfClass("Humanoid") and User.Character:FindFirstChildOfClass("Humanoid").RigType == Enum.HumanoidRigType.R15 then
			SUPERMANN = User.Character:FindFirstChildOfClass("Humanoid"):LoadAnimation(SUPERMAN) SUPERMANN.Priority = Enum.AnimationPriority.Action SUPERMANN.TimePosition = 1 SUPERMANN.Looped = true if Config.flight==true and Config.superman==true then SUPERMANN:Play(.1,1,0) end 
		elseif User.Character:FindFirstChildOfClass("Humanoid") then
			SUPERMANN = User.Character:FindFirstChildOfClass("Humanoid"):LoadAnimation(SUPERMANR6) SUPERMANN.Priority = Enum.AnimationPriority.Action SUPERMANN.TimePosition = .09 SUPERMANN.Looped = true if Config.flight==true and Config.superman==true then SUPERMANN:Play(.1,1,0) end
		end
		changestatus(UserHum)
	end)
end) 
--- Thank you xHeptc for making the super duper sexy nigger gui lib
game:GetService("RunService").RenderStepped:connect(function() -- Constant updater to ease up resource use
	Camera = workspace.CurrentCamera
	Resolution = Vector2.new(Mouse.ViewSizeX,Mouse.ViewSizeY)
	if SUPERMANN then
		if Rig == Enum.HumanoidRigType.R15 then
			SUPERMANN.Priority = Enum.AnimationPriority.Action
			SUPERMANN.TimePosition = 1
			SUPERMANN.Looped = true
		else
			SUPERMANN.Priority = Enum.AnimationPriority.Action 
			SUPERMANN.TimePosition = .12 
			SUPERMANN.Looped = true
		end
		if Config.CROSS==true then
			CR1.Visible = true
			CR2.Visible = true
			local maths = (Resolution.Y*(math.abs(Config.CROSSS)/1000))
			CR1.From = Vector2.new(Mouse.X-maths,Mouse.Y+inset)
			CR1.To = Vector2.new(Mouse.X+maths,Mouse.Y+inset)
			CR1.Thickness = (Resolution.Y*.0025)
			CR2.From = Vector2.new(Mouse.X,Mouse.Y+inset+maths)
			CR2.To = Vector2.new(Mouse.X,Mouse.Y+inset-maths)
			CR2.Thickness = (Resolution.Y*.0025)
			CR1.Color = Config.CROSSC and Config.CROSSC[1] and Config.CROSSC[2] and Config.CROSSC[3] and Color3.new(Config.CROSSC[1],Config.CROSSC[2],Config.CROSSC[3]) or Color3.new(1,1,1)
			CR2.Color = Config.CROSSC and Config.CROSSC[1] and Config.CROSSC[2] and Config.CROSSC[3] and Color3.new(Config.CROSSC[1],Config.CROSSC[2],Config.CROSSC[3]) or Color3.new(1,1,1)
			CR1.ZIndex = lowvalue
			CR2.ZIndex = lowvalue
            if Config.CROSSTRAN then
            CR1.Transparency = Config.CROSSTRAN/100 else CR1.Transparency = 1 end
            CR2.Transparency = CR1.Transparency
		else
			CR1.Visible = false
			CR2.Visible = false
		end
		if Config.AIMBOT==true and game:GetService("GuiService").MenuIsOpen==false then 
			AIMSTATUS.Visible=true
			AIMSTATUS.Font = Config.FONT
			AIMSTATUS.Color = Config.CROSS and CR1.Color:Lerp(Color3.new(1,1,1),.5) or Color3.new(1,1,1)
			AIMSTATUS.OutlineColor = Color3.new(0,0,0)
			AIMSTATUS.Transparency = Config.CROSS==true and Config.CROSSTRAN and Config.CROSSTRAN/100 or 0
			AIMSTATUS.Size = Resolution.Y*0.03
			AIMSTATUS.Center = true
			AIMSTATUS.Position = Vector2.new(Mouse.X+AIMSTATUS.TextBounds.X/1.5,Mouse.Y+inset-AIMSTATUS.TextBounds.Y)

			AIMSTATUS2.Visible=AIMSTATUS.Visible
			AIMSTATUS2.Font = AIMSTATUS.Font
			AIMSTATUS2.Color = AIMSTATUS.Color
			AIMSTATUS2.OutlineColor = AIMSTATUS.OutlineColor
			AIMSTATUS2.Transparency = AIMSTATUS.Transparency
			AIMSTATUS2.Size = AIMSTATUS.Size
			AIMSTATUS2.Center = true
			AIMSTATUS2.Position = Vector2.new(AIMSTATUS.Position.X+AIMSTATUS.TextBounds.X/2+AIMSTATUS2.TextBounds.X/2,AIMSTATUS.Position.Y)
		else
			AIMSTATUS.Visible=false
			AIMSTATUS2.Visible=AIMSTATUS.Visible
		end
		if PATHFINDING then 
            --PATHSTATUS
		end
	end
    if Config.XRAYB==true and Config.XRAYBU==true then
    XRAY(Config.XRAYM)  end
end)


--- A little bit of insight, this script is the rebirth of Skidmund, a script I never released, aspiring the same objective, but in a much more efficient way.
---
--[[ Reference
local Tab= Library.CreateLib("TITLE", "DarkTheme")

local Section = Tab:NewSection("Section Name")

Section:UpdateSection("Section New Title")

Section:NewLabel("LabelText")

label:UpdateLabel("New Text")

Section:NewButton("ButtonText", "ButtonInfo", function()
    print("Clicked")
end)

button:UpdateButton("New Text")

Section:NewToggle("ToggleText", "ToggleInfo", function(state)
    if state then
        print("Toggle On")
    else
        print("Toggle Off")
    end
end)

Section:NewSlider("SliderText", "SliderInfo", 500, 0, function(s) -- 500 (MaxValue) | 0 (MinValue)
    game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = s
end)

Section:NewTextBox("TextboxText", "TextboxInfo", function(txt)
	print(txt)
end)

Section:NewKeybind("KeybindText", "KeybindInfo", Enum.KeyCode.F, function()
	print("You just clicked the bind")
end)


Library:ToggleUI()

Section:NewDropdown("DropdownText", "DropdownInf", {"Option 1", "Option 2", "Option 3"}, function(currentOption)
    print(currentOption)
end)

]]
---

--[[
if antiantitp then
local state,waypoints = findpath(UserChar:GetModelCFrame().p,pos.p,AllocatedPath)
if state==Enum.PathStatus.Success then
for _,point in pairs(waypoints) do
local n,s = GetBoundingBox(UserChar,true)
local calctime = TweenInfo.new((point.Position-hr.CFrame.p).Magnitude/math.pow(UserHum.WalkSpeed,2))
local temptween = game:GetService("TweenService"):Create(hr,calctime,{CFrame = CFrame.new(point.Position+Vector3.new(0,s.Y/2,0))*hr.CFrame.Rotation})
temptween:Play()
temptween.Completed:Wait()
end
else 
local n,s = GetBoundingBox(UserChar,true)
local calctime = TweenInfo.new((pos.Position-hr.CFrame.p).Magnitude/math.pow(UserHum.WalkSpeed,2))
local temptween = game:GetService("TweenService"):Create(hr,calctime,{CFrame = CFrame.new(pos.Position+Vector3.new(0,s.Y/2,0))*hr.CFrame.Rotation})
temptween:Play()
end
else
UserChar:PivotTo(pos)
end
]]

---
DeletedInstances = {}
TPRaycastConfig = RaycastParams.new()
TPRaycastConfig.FilterType = Enum.RaycastFilterType.Blacklist
TPRaycastConfig.IgnoreWater = true
Mouse.Button1Down:connect(function()
if Config.CLICKTP==true and Mouse and FIRING == false then
if teleportingtowardspoint then return end
if UserChar then
teleportingtowardspoint = true
local n,s = GetBoundingBox(UserChar,false)
TPRaycastConfig.FilterDescendantsInstances={workspace.CurrentCamera,UserChar}
local raycast = workspace:Raycast(workspace.CurrentCamera.CFrame.p,Mouse.UnitRay.Direction*5000,TPRaycastConfig)
if raycast and raycast.Instance and raycast.Position then else UserChar:PivotTo(CFrame.new(Mouse.Hit.p)*UserChar:GetModelCFrame().Rotation) return end
--local offset = CLICKTPOFFSET and Vector3.new(0,s.Y/2,0) or Vector3.new(0,0,0)
if UserHum then UserHum.Sit = false end
game:GetService("RunService").Heartbeat:Wait()

if Config.antiantitp==true then 

local state,waypoints = findpath(UserChar:GetModelCFrame().p,raycast.Position,AllocatedPath)
if state==Enum.PathStatus.Success then
for _,point in pairs(waypoints) do
local calctime = TweenInfo.new((point.Position-hr.CFrame.p).Magnitude/math.pow(UserHum.WalkSpeed,2))
local temptween = game:GetService("TweenService"):Create(hr,calctime,{CFrame = CFrame.new(point.Position+Vector3.new(0,s.Y/2,0))*hr.CFrame.Rotation})
temptween:Play()
temptween.Completed:Wait()
end
else
local calctime = TweenInfo.new((raycast.Position-hr.CFrame.p).Magnitude/math.pow(UserHum.WalkSpeed,2))
local temptween = game:GetService("TweenService"):Create(hr,calctime,{CFrame = CFrame.new(raycast.Position+Vector3.new(0,s.Y/2,0))*hr.CFrame.Rotation})
temptween:Play()
end

else
UserChar:PivotTo(CFrame.new(raycast.Position+Vector3.new(0,s.Y/2,0))*UserChar:GetModelCFrame().Rotation) end

if hr and raycast.Instance and raycast.Instance:IsA("BasePart") then hr.AssemblyLinearVelocity = raycast.Instance.AssemblyLinearVelocity end
end
teleportingtowardspoint = false
end

if Config.CLICKDEL==true and Mouse and FIRING == false then
if Mouse.Target then if Mouse.Target:FindFirstAncestorWhichIsA("Model") and Mouse.Target:FindFirstAncestorWhichIsA("Model"):FindFirstChildOfClass("Humanoid") or Mouse.Target:FindFirstAncestorWhichIsA("Camera") or table.find(DeletedInstances,Mouse.Target) then else
DeletedInstances[Mouse.Target]={Mouse.Target,Mouse.Target.Size}
Mouse.Target.Size = Vector3.new(0,0,0)
end
end
end
end)

--- Global Variables
Config = {}
Config.ESP = false
Config.flight = false
Config.flightnograv = false
Config.nograv = false
Config.fspeed = 10
Config.spdsp=16
Config.spd=false
Config.superman=false
Config.CROSS=false
Config.CROSSC={1,1,1}
Config.CROSSS=15
Config.IMMORTALITY=false
Config.SWIM=false
Config.XRAYB=false
Config.HESPT = false
Config.NTAGST = false
Config.NTAGSV = 150
Config.NTAGV = 15
Config.firedelay = 1/5
Config.FOVSET = false
Config.CROSSTRAN = 100
Config.XRAYM = 0
Config.AFELOOP = false
Config.FIDGETSPINNER = false
Config.verticallock = false
Config.CLICKDELTOG=false
Config.CLICKTPTOG=false
Config.aimbotkbmode = "None"
Config.AIMBOT = false
Config.TRIGGERBOT = false
Config.MOUSESPOOF = false
Config.autowalk = false
Config.OKBPS = 64
Config.RLAG = 0
Config.FPDSD = false
Config.CLICKTP = false
Config.CLICKDEL = false
Config.fspinnernoclip = false
Config.COLOREDBOXES = false
Config.ARW = false
Config.HLT = false
Config.TRACERST = false
Config.FONT = Drawing.Fonts["UI"]
Config.XRAYBU = false
Config.SPEEDDRIFT = false
Config.antiantitp = false
Config.teamcheck = false
Config.wallcheck = false
Config.aimspeed = 10
Config.headaim = false
Config.shootrad = 10
Config.RANDOMTGT= false
Config.CurrentExploit = identifyexecutor() or nil
Config.FOV = workspace.CurrentCamera.FieldOfView
Config.LockTarget = false

--- Debounces below
FIRING = false
MAPRESTORING = false
teleportingtowardspoint = false

spawn(function() while true do if workspace.CurrentCamera and Config.FOVSET==true then workspace.CurrentCamera.FieldOfView = Config.FOV or tempfov workspace.CurrentCamera.Changed:Wait() else game:GetService("RunService").RenderStepped:Wait() end end end) --- This is the FOV magic

---
local GUI = Gaylib.CreateLib("X-PL0X", "BloodTheme")
local Visuals = GUI:NewTab("Visuals")
local ESPS = Visuals:NewSection("Render")
local ESPTOG = ESPS:NewToggle("ESP", "Toggles ESP duh", function(state)
		Config.ESP = state
end)
local CROSSTOG = ESPS:NewToggle("Crosshair", "'Nice crosshair, where'd you get it?'", function(state)
	Config.CROSS = state
end)
local XRAYTOG = ESPS:NewToggle("X-Ray", "'This nigga's superman or something..'", function(state)
Config.XRAYB = state
if state then XRAY(0) else XRAY(Config.XRAYM) end
end)
local FOVTOG = ESPS:NewToggle("FOV", "'Widelens simulator'", function(state)
Config.FOVSET = state
Config.FOV = workspace.CurrentCamera.FieldOfView
end)
ESPS:NewSlider("FOV amount", "'Widelens simulator'", 120, 1, function(s)
Config.FOV = s
end)
local Util = GUI:NewTab("Utilities")
local SPDS = Util:NewSection("Movement")
local SPDT = SPDS:NewToggle("Walkspeed","run fast as fuck boiiiii",function(state)Config.spd=state end)
local FLYT = SPDS:NewToggle("Flight", "you fly duh", function(state)
if not state and Config.FIDGETSPINNER==true then turnflightbackon() return end --- literally fucking stupid bro
	if state then
		movedir=Vector3.new(0,0,0)
		if UserHum then UserHum.Sit = false end
		game:GetService("RunService").Heartbeat:Wait()
		Config.flight=true
		spawn(function() ---- This is the only fucking way I can do it
			repeat wait() until UserHum
			local FallingDown = UserHum:GetStateEnabled(Enum.HumanoidStateType.FallingDown)
			local Running = UserHum:GetStateEnabled(Enum.HumanoidStateType.Running)
			local RunningNoPhysics = UserHum:GetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics)
			local Climbing = UserHum:GetStateEnabled(Enum.HumanoidStateType.Climbing)
			local StrafingNoPhysics = UserHum:GetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics)
			local Ragdoll = UserHum:GetStateEnabled(Enum.HumanoidStateType.Ragdoll)
			local GettingUp = UserHum:GetStateEnabled(Enum.HumanoidStateType.GettingUp)
			local Jumping = UserHum:GetStateEnabled(Enum.HumanoidStateType.Jumping)
			local Landed = UserHum:GetStateEnabled(Enum.HumanoidStateType.Landed)
			local Flying = UserHum:GetStateEnabled(Enum.HumanoidStateType.Flying)
			local Freefall = UserHum:GetStateEnabled(Enum.HumanoidStateType.Freefall)
			local Seated = UserHum:GetStateEnabled(Enum.HumanoidStateType.Seated)
			local PlatformStanding = UserHum:GetStateEnabled(Enum.HumanoidStateType.PlatformStanding)
			local Swimming = UserHum:GetStateEnabled(Enum.HumanoidStateType.Swimming)
			local Physics = UserHum:GetStateEnabled(Enum.HumanoidStateType.Physics)
			local None = UserHum:GetStateEnabled(Enum.HumanoidStateType.None)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.FallingDown,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Running,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Climbing,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.GettingUp,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Jumping,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Landed,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Flying,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Freefall,true)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Seated,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Swimming,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Physics,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.None,false)
			spawn(function() repeat wait() until Config.flight==false
				UserHum:SetStateEnabled(Enum.HumanoidStateType.FallingDown,FallingDown)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Running,Running)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics,RunningNoPhysics)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Climbing,Climbing)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics,StrafingNoPhysics)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,Ragdoll)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.GettingUp,GettingUp)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Jumping,Jumping)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Landed,Landed)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Flying,Flying)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Freefall,Freefall)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Seated,Seated)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding,PlatformStanding)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Swimming,Swimming)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Physics,Physics)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.None,None)
			end) end)
		if SUPERMANN and Config.superman==true then SUPERMANN:Play(.1,1,0) end
	else Config.flight=false movedir=Vector3.new(0,0,0) if SUPERMANN then SUPERMANN:Stop() end
	end
	changestatus(UserHum)
end)
function turnflightbackon() FLYT:UpdateToggle("Flight",true) end --- most simple retarded solution I could find
local VLOCKTOG = SPDS:NewToggle("Vertical lock", "Tired of falling?", function(state)
Config.verticallock=state
currentheight = hr and hr.CFrame.p or UserChar and UserChar:GetModelCFrame() or Vector3.new(0,0,0)
end)
local CLICKTPT = SPDS:NewToggle("Click teleport", "Check the settings for it before using", function(state)
Config.CLICKTPTOG=state
end)
local CLICKDELT = SPDS:NewToggle("Click 'delete'", "Check the settings for it before using", function(state)
Config.CLICKDELTOG=state
end)
SPDS:NewButton("Restore map", "Hate what you did to it?", function()
if MAPRESTORING == false then
MAPRESTORING = true
for _,Brick in pairs(DeletedInstances) do
if Brick[1] and Brick[2] then
Brick[1].Size = Brick[2]
DeletedInstances[_]=nil
else DeletedInstances[_]=nil
end
end
MAPRESTORING = false
end
end)
local AMBTS = Util:NewSection("Automation")
local AIMBOTTOG = AMBTS:NewToggle("Aimbot", "Automates the whole aiming process", function(state)
Config.AIMBOT=state
end)
local triggerbottog = AMBTS:NewToggle("Triggerbot", "Automates the whole aiming process", function(state)
Config.TRIGGERBOT=state
end)
local mousespooftog = AMBTS:NewToggle("Silent Aim", "spoofs aiming in on itself", function(state)
Config.MOUSESPOOF = state
if not state then game:GetService("RunService").Heartbeat:Wait() spoofer:unspoof(Mouse) end
end)
local AIMBOTKBMODE = AMBTS:NewDropdown("Aim key mode", "i'm a fucking genius bro", {"None", "Toggle", "Hold"}, function(currentOption)
Config.aimbotkbmode = currentOption
end)
local AUTOWALKTOG = AMBTS:NewToggle("Auto walk", "if noob then walktonoob() end", function(state)
Config.autowalk = state
end)

local Spoofing = GUI:NewTab("Spoofing")
---
local SPFN = Spoofing:NewSection("Network")
local BRAZILWIFI = SPFN:NewTextBox("Outbound KB/s", "Max (and default) is 64KB/s", function(am)
	Config.OKBPS = math.clamp(math.abs(tonumber(am)),1,64) or 64
    game:GetService("NetworkClient"):SetOutgoingKBPSLimit(Config.OKBPS)
end)
local BRAZILPING = SPFN:NewTextBox("Replication lag", "It's a multiplier. Any number.", function(am)
	Config.RLAG = tonumber(math.abs(am)) or 0
    settings().Network.IncomingReplicationLag = Config.RLAG
end)
---
local Misc = GUI:NewTab("Miscellaneous")
local MiscVis = Misc:NewSection("Visuals (some might not work because roblox)")
MiscVis:NewToggle("'Wireframe'", "It's supposed to work....", function(state)
    settings().Rendering.RenderCSGTrianglesDebug = state
end)
MiscVis:NewToggle("Bounding Boxes", "Draws box around EVERYTHING", function(state)
    settings().Rendering.ShowBoundingBoxes = state
end)
MiscVis:NewToggle("VRAM unlocker", "Disables vram cap", function(state)
    settings().Rendering.EagerBulkExecution = state
end)
MiscVis:NewTextBox("Change mesh cache", "Default size is 32MB", function(state)
    settings().Rendering.MeshCacheSize = tonumber(state) or 32
end)
MiscVis:NewToggle("Diagnostic mode", "Toggles diagnostic mode", function(state)
    if state then settings().Rendering.GraphicsMode = Enum.GraphicsMode.NoGraphics
    else
    settings().Rendering.GraphicsMode = Enum.GraphicsMode.Automatic end
end)
local Prot = GUI:NewTab("Protection")
local MSECT = Prot:NewSection("Character")
local MTOG = MSECT:NewToggle("Disable death","Death? Is this a bad joke?",function(state)
	Config.IMMORTALITY=state
	spawn(function()
		repeat wait() until UserHum
		local hst = UserHum:GetStateEnabled(15)
		if state then spawn(function() repeat wait() until Config.IMMORTALITY==false UserHum:SetStateEnabled(15,hst) end) end
	end)
	changestatus(UserHum)
end)
local FELOOPPROTTOG = MSECT:NewToggle("Anti feloop","Prevents tool equipping",function(state)
Config.AFELOOP=state
end)
local FPDST = MSECT:NewToggle("Ignore destruction layer","Fall for 99999 seconds challenge",function(state)
	Config.FPDSD = state
	spawn(function()
		local hst = workspace.FallenPartsDestroyHeight
		workspace.FallenPartsDestroyHeight = math.huge-math.huge
		if Config.FPDSD==true then spawn(function() repeat wait() until Config.FPDSD==false workspace.FallenPartsDestroyHeight=hst end) end
	end)
end)
local Gim = GUI:NewTab("Gimmicks")
local CharGim = Gim:NewSection("Character")
local TrollGim = Gim:NewSection("Trolling")
sounddebounce = false
local PlaySounds = TrollGim:NewButton("Fuck... I hate niggers....", "Plays every sound [FE]", function()
if sounddebounce then return else sounddebounce = true end
spawn(function() wait(1) sounddebounce=false end)
for _,S in pairs(workspace:GetDescendants()) do if S:IsA("Sound") then S:Play() end end
end)
local StopSounds = TrollGim:NewButton("NIGGERS ARE BLACK BRO!!!! SCARY.", "Stops every sound [FE]", function()
if sounddebounce then return else sounddebounce = true end
spawn(function() wait(1) sounddebounce=false end)
for _,S in pairs(workspace:GetDescendants()) do if S:IsA("Sound") then S:Stop() end end
end)
local ScrambleSounds = TrollGim:NewButton("Poop. Toluene Miller gay sex.", "Stops every sound [FE]", function()
if sounddebounce then return else sounddebounce = true end
spawn(function() wait(1) sounddebounce=false end)
for _,S in pairs(workspace:GetDescendants()) do if S:IsA("Sound") then S:Pause() S.TimePosition = math.random(0,S.TimeLength) S:Resume() end end
end)
local EARRAPE = TrollGim:NewButton("Poop. Toluene Miller gay sex.", "Stops every sound [FE]", function()
if sounddebounce then return else sounddebounce = true end
spawn(function() wait(1) sounddebounce=false end)
for _,S in pairs(workspace:GetDescendants()) do if S:IsA("Sound") then S:Pause() local oldvol = S.Volume S.Volume=10 local earrape = Instance.new("DistortionSoundEffect",S) earrape.Level = .5 earrape.Priority = 2^31 S:Resume() spawn(function() repeat wait() until S.Stopped S.Volume = oldvol earrape:Remove() end) end end
end)
local FidgetSpinner = TrollGim:NewToggle("Fidget spinner", "This is a certified hood classic.", function(state)
Config.FIDGETSPINNER = state
if state then FLYT:UpdateToggle("Flight",true) else hr.AssemblyAngularVelocity = Vector3.new(0,0,0) end
end)
local FIDGETSPINNERNOCLIP = TrollGim:NewToggle("Fidget spinner noclip", "No moure bouncing!!!!", function(state)
Config.fspinnernoclip = state
end)
function updsoundtroll() --- too lazy to copypaste the same function twice lol
if game:GetService("SoundService").RespectFilteringEnabled==true then
PlaySounds:UpdateButton("Play sounds [Local]")
StopSounds:UpdateButton("Stop sounds [Local]")
ScrambleSounds:UpdateButton("Scramble sounds [Local]")
EARRAPE:UpdateButton("Earrape playback [Local]")
else
PlaySounds:UpdateButton("Play sounds [Global]")
StopSounds:UpdateButton("Stop sounds [Global]")
ScrambleSounds:UpdateButton("Scramble sounds [Global]")
EARRAPE:UpdateButton("Earrape playback [Global]")
end end updsoundtroll()
function swimfunc(a)
	spawn(function() ---- This is the only fucking way I can do it
		repeat wait() until UserHum
        if FallingDown and Running and RunningNoPhysics and Climbing and StrafingNoPhysics and Ragdoll and GettingUp and Jumping and Landed and Flying and Freefall and Seated and PlatformStanding and Swimming and Physics then else

		FallingDown = UserHum:GetStateEnabled(Enum.HumanoidStateType.FallingDown)
		Running = UserHum:GetStateEnabled(Enum.HumanoidStateType.Running)
		RunningNoPhysics = UserHum:GetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics)
		Climbing = UserHum:GetStateEnabled(Enum.HumanoidStateType.Climbing)
		StrafingNoPhysics = UserHum:GetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics)
		Ragdoll = UserHum:GetStateEnabled(Enum.HumanoidStateType.Ragdoll)
		GettingUp = UserHum:GetStateEnabled(Enum.HumanoidStateType.GettingUp)
		Jumping = UserHum:GetStateEnabled(Enum.HumanoidStateType.Jumping)
		Landed = UserHum:GetStateEnabled(Enum.HumanoidStateType.Landed)
		Flying = UserHum:GetStateEnabled(Enum.HumanoidStateType.Flying)
		Freefall = UserHum:GetStateEnabled(Enum.HumanoidStateType.Freefall)
		Seated = UserHum:GetStateEnabled(Enum.HumanoidStateType.Seated)
		PlatformStanding = UserHum:GetStateEnabled(Enum.HumanoidStateType.PlatformStanding)
		Swimming = UserHum:GetStateEnabled(Enum.HumanoidStateType.Swimming)
		Physics = UserHum:GetStateEnabled(Enum.HumanoidStateType.Physics)
		--local None = UserHum:GetStateEnabled(Enum.HumanoidStateType.None)
        end
        UserHum:SetStateEnabled(Enum.HumanoidStateType.FallingDown,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Running,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Climbing,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.GettingUp,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Jumping,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Landed,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Flying,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Freefall,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Seated,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Swimming,true)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Physics,false)
		--UserHum:SetStateEnabled(Enum.HumanoidStateType.None,false)
		repeat wait() until Config.SWIM==false or User.CharacterAdded
            if Config.SWIM==false then
            local UserHum = User.Character:FindFirstChildOfClass("Humanoid")
            if UserHum then
			UserHum:SetStateEnabled(Enum.HumanoidStateType.FallingDown,FallingDown)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Running,Running)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics,RunningNoPhysics)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Climbing,Climbing)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics,StrafingNoPhysics)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,Ragdoll)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.GettingUp,GettingUp)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Jumping,Jumping)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Landed,Landed)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Flying,Flying)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Freefall,Freefall)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Seated,Seated)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding,PlatformStanding)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Swimming,Swimming)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Physics,Physics)
			--UserHum:SetStateEnabled(Enum.HumanoidStateType.None,None)
            FallingDown,Running,RunningNoPhysics,Climbing,StrafingNoPhysics,Ragdoll,GettingUp,Jumping,Landed,Flying,Freefall,Seated,PlatformStanding,Swimming,Physics = nil
            end
            elseif Config.SWIM==true then swimfunc() end
	end)
end --- another retard solution
game:GetService("SoundService").Changed:Connect(function(s) if s=="RespectFilteringEnabled" then updsoundtroll() end end) --- in case something changes FE sounds mid-game.
local swmT = CharGim:NewToggle("Air swim","Do crabs think fish fly?",function(state)
	Config.SWIM = state
    if state then swimfunc() end
	changestatus(UserHum)
end)
local NOGRAV = CharGim:NewToggle("No gravity", "poland cannot into space", function(state) 
Config.nograv = state
end)

--[[
Will be added later
local Spoofing = GUI:NewTab("Spoofing")
local Misc = GUI:NewTab("Miscellaneous")
local Prot = GUI:NewTab("Protection") 
local Util = GUI:NewTab("Utilities")
local Gim = GUI:NewTab("Gimmicks")
]]
---
local Statsz = GUI:NewTab("Stats")
local ClientStats = Statsz:NewSection("Client")
local ServerStats = Statsz:NewSection("Server")

local FPSL = ClientStats:NewLabel("FPS")
local PINGL = ClientStats:NewLabel("Ping")
local PhysL = ClientStats:NewLabel("Physics TPS")
local PhysLR = ClientStats:NewLabel("REAL")

local TPSL = ServerStats:NewLabel("TPS")
local PTPSL = ServerStats:NewLabel("Physics TPS")
---
local Settings = GUI:NewTab("Settings")
local ESPSET = Settings:NewSection("ESP")
local CROSSSET = Settings:NewSection("Crosshair")
local XRAYSET = Settings:NewSection("X-Ray")
local TEAMCOLOREDBOXt = ESPSET:NewToggle("Team coloured boxes", "have sex with children", function(state) 
	Config.COLOREDBOXES=state
end)
local mn = ESPSET:NewToggle("Directional Arrows", "y u no like dem??", function(state) 
	Config.ARW=state
end)
local mn2 = ESPSET:NewToggle("Healthbar", "buh 💀", function(state) 
	Config.HLT=state
end)
local HESP = ESPSET:NewToggle("Show heads", "gg ez onetap", function(state) 
Config.HESPT = state
end)
local TRACERS = ESPSET:NewToggle("Tracers", "omg guys i found him!!", function(state) 
Config.TRACERST = state
end)
local NTAG = ESPSET:NewToggle("Nametags", "u n00b ncca?", function(state) 
Config.NTAGST = state
end)
local NTAGO = ESPSET:NewSlider("Nametag offset", "(Y%)", 400, -400, function(s)
Config.NTAGSV = s
end)
local NTAGS = ESPSET:NewTextBox("Nametag size", "Any non-imaginary number", function(s)
Config.NTAGV = s
end)
local FONTz = ESPSET:NewDropdown("Font", "I like your style.", {"UI", "System", "Plex", "Monospace"}, function(currentOption)
Config.FONT = Drawing.Fonts[currentOption]
end)

local CROSSCS = CROSSSET:NewColorPicker("Crosshair color", "Choose whatever color", Color3.fromRGB(255,255,255), function(color)
	Config.CROSSC = {color.R,color.G,color.B}
end)
local CROSSTRANSEL = CROSSSET:NewSlider("Crosshair (%)", "How opaque?", 100, 0, function(s)
	Config.CROSSTRAN = s
end)
local CROSSSZ = CROSSSET:NewTextBox("Crosshair size","Any non-imaginary number", function(am)
	Config.CROSSS = tonumber(am) or 15
end)
local XRAYSETT = XRAYSET:NewSlider("X-Ray (%)", "100% = map is invisible", 100, 0, function(s)
Config.XRAYM = s/100
end)
local AUTOUPDXRAY = XRAYSET:NewToggle("X-Ray autoupdate", "VERY resource intensive", function(state) 
Config.XRAYBU=state
end)
local UPDXRAY = XRAYSET:NewButton("X-Ray manual update", "Manually update X-RAY", function() 
if Config.XRAYB==true then
XRAY(Config.XRAYM)
end
end)

local SPDSET = Settings:NewSection("Movement")
local FLYSP = SPDSET:NewTextBox("Flight speed","Any non-imaginary number", function(am)
	Config.fspeed = tonumber(am) or 10
end)
local SUPRMN = SPDSET:NewToggle("Superman mockup", "wtf are you superman ncca?", function(state) Config.superman=state 
	if state and SUPERMANN then
		spawn(function()
			repeat wait() until Config.flight==true
			if Config.superman==false then else
				if SUPERMANN then
					SUPERMANN.Priority = Enum.AnimationPriority.Action
					SUPERMANN.TimePosition = 1
					SUPERMANN.Looped = true
					SUPERMANN:Play(.1,1,0) end
			end
		end)
	elseif not state or Config.flight==false then
		if SUPERMANN then
			SUPERMANN:Stop() 
		end
	end
end)
local FLIGHTNOGRAV = SPDSET:NewToggle("Anti flight drift", "prevents vertical drift", function(state) 
Config.flightnograv = state
end)
local SPDP = SPDSET:NewTextBox("Walkspeed","Any non-imaginary number", function(am)
	Config.spdsp = tonumber(am) or 16
end)
local SPDDRFT = SPDSET:NewToggle("Anti slip","Any non-imaginary number", function(am)
Config.SPEEDDRIFT = am
end)
local BINDSET = Settings:NewSection("Keybinds")
local CLICKTPKB = BINDSET:NewKeybind("Click teleport bind", "This is the keybind for it", Enum.KeyCode.LeftControl, function(bind)
if Config.CLICKTPTOG==true and FIRING == false then
if Config.CLICKTP==true then
Config.CLICKTP = false
else Config.CLICKTP = true spawn(function() while game:GetService("UserInputService"):IsKeyDown(bind) do game:GetService("UserInputService").InputEnded:Wait() end Config.CLICKTP = false end)
end
end
end)
local CLICKDELKB = BINDSET:NewKeybind("Click delete bind", "This is the keybind for it", Enum.KeyCode.RightAlt, function(bind)
if Config.CLICKDELTOG==true and FIRING == false and MAPRESTORING==false then
if Config.CLICKDEL==true then
Config.CLICKDEL = false
else Config.CLICKDEL = true spawn(function() while game:GetService("UserInputService"):IsKeyDown(bind) do game:GetService("UserInputService").InputEnded:Wait() end Config.CLICKDEL = false end)
end
end
end)
local FLIGHTKB = BINDSET:NewKeybind("Click delete bind", "This is the keybind for it", Enum.KeyCode.KeypadPlus, function(bind)
if Config.flight==true then
FLYT:UpdateToggle("Flight",false) else FLYT:UpdateToggle("Flight",true) end
end)
local AIMBOTKB = BINDSET:NewKeybind("Aimbot bind", "This is the keybind for it", Enum.KeyCode.V, function(bind)
if Config.AIMBOT==true then
if Config.aimbotkbmode=="Toggle" then
AIMBOTTOG:UpdateToggle("Aimbot",false)Config.AIMBOT=false end
else 
if Config.aimbotkbmode=="Toggle" then
AIMBOTTOG:UpdateToggle("Aimbot",true)Config.AIMBOT=true
elseif Config.aimbotkbmode=="Hold" then AIMBOTTOG:UpdateToggle("Aimbot",true) spawn(function() while game:GetService("UserInputService"):IsKeyDown(bind) or Config.AIMBOT==false do game:GetService("UserInputService").InputEnded:Wait() end AIMBOTTOG:UpdateToggle("Aimbot",false) end) end
end
end)


local TARGETSETBANNER = Settings:NewSection("Targeting")
local TGTLIST = TARGETSETBANNER:NewTextBox("Target", "FETCH ME THEIR SOULS!!!!", function(txt)
TGT = MatchName(txt)
end)
local TPTOBTN = TARGETSETBANNER:NewButton("Teleport", "Instant transmission?", function(txt)
if not teleportingtowardspoint then else return end
teleportingtowardspoint = true
local pos = UserChar:GetModelCFrame()
if TGT and TGT[1] and TGT[1].Character and Config.RANDOMTGT~=true then 
		if UserHum then UserHum.Sit = false end
		game:GetService("RunService").Heartbeat:Wait()
pos = TGT[1].Character:GetModelCFrame()
else
		if UserHum then UserHum.Sit = false end
		game:GetService("RunService").Heartbeat:Wait()
pos = randomplayer().Character:GetModelCFrame()
end
if Config.antiantitp==true then
local n,s = GetBoundingBox(UserChar,false)
local radius = s.X>s.Z and s.X or s.Z
local state,waypoints = findpath(UserChar:GetModelCFrame().p,pos.p,game:GetService("PathfindingService"):CreatePath({AgentRadius=radius,AgentHeight=s.Y,AgentCanJump = true}))
if state==Enum.PathStatus.Success then
for _,point in pairs(waypoints) do
Phys:MoveTo(hr,CFrame.new(point.Position),1)
warn("noger")
local tptimeout = true
spawn(function() wait(10) if tptimeout then return  end end)
repeat wait() until (hr.Position-point.Position).Magnitude<3
tptimeout = nil
end
Phys:PurgePhysics(hr)
else 
local n,s = GetBoundingBox(UserChar,false)
local calctime = TweenInfo.new((pos.Position-hr.CFrame.p).Magnitude/math.pow(UserHum.WalkSpeed,2))
local temptween = game:GetService("TweenService"):Create(hr,calctime,{CFrame = CFrame.new(pos.Position+Vector3.new(0,s.Y/2,0))*hr.CFrame.Rotation})
temptween:Play()
end
else
UserChar:PivotTo(pos)
end
teleportingtowardspoint = false
end)
local ANTIANTITPt = TARGETSETBANNER:NewToggle("Anti anti tp", "ayo wtf", function(ms)
Config.antiantitp = ms
end)
local AIMBOTSETBANNER = Settings:NewSection("Aimbot")
local TEAMCHECK = AIMBOTSETBANNER:NewToggle("Team check", "friendly fire is banned!!", function(state)
Config.teamcheck = state
end)
local WALLCHECK = AIMBOTSETBANNER:NewToggle("Wall check", "friendly fire is banned!!", function(state)
Config.wallcheck = state
end)
local AIMSPEED = AIMBOTSETBANNER:NewTextBox("Aim speed", "gay fart sex penis", function(s)
local aimspeedz = tonumber(s) or 10
Config.aimspeed = aimspeedz
end)
local HEADAIM = AIMBOTSETBANNER:NewToggle("Headshot", "onetap 2.0 (real)", function(state)
Config.headaim = state
end)
local SHOOTRAD = AIMBOTSETBANNER:NewTextBox("Trigger radius", "BOOM HEADSHOT!", function(am)
Config.shootrad = tonumber(am) or 10
end)
local SHOOTSPEED = AIMBOTSETBANNER:NewTextBox("Shots per second", "BRRRT", function(am)
local number = 1000
if tonumber(am) then number = am end
Config.firedelay = 1/number
end)
local LOCKTARGETTOG = AIMBOTSETBANNER:NewToggle("Lock target", "tired of spinning?", function(state)
Config.LockTarget = state
end)
local RANDOMTARGETTOGGLE = TARGETSETBANNER:NewToggle("Random target", "Chooses any target at random", function(state) 
Config.RANDOMTGT=state
end)
---
local Credits = GUI:NewTab("Credits")
local Thx = Credits:NewSection("Thanks to:")
local Thxwho = Thx:NewLabel("Github - home of this shit")
local Thxwho2 = Thx:NewLabel("xHeptc - fuck you nigga why can't I fuck this UI???")
local Thxwho3 = Thx:NewLabel("rqccc - taught me how to get server ping")
local Thxwho4 = Thx:NewLabel("ic3w0lf22 - tracer code used for aimbot and tracers")
local DC = GUI:NewTab("Discord")
local mm=DC:NewSection("Discord Server")
local m=mm:NewButton("Copy to clipboard", "copies discord invite to clipboard", function()
if discorddebounce then else
	setclipboard('https://discord.gg/eCtE2ukNVV')
	m:UpdateButton("Copied!")
    discorddebounce=true
	wait(1)
    discorddebounce=nil
	m:UpdateButton("Copy to clipboard")
end
end)
---
--[[  So yeah this is ESP template and stuff

[Player] = 
{
    Plr,
    Box,
    Healthbar = {},
    Arrow = {},
}

]]
--- Custom Functions and shit
PLAYERLIST = {}
lowvalue = 2^31-1
highvalue = -lowvalue
--StatsService = game:GetService("Stats") --- redundant af
StatsService = stats()
UserInputService = game:GetService("UserInputService")
DELTA = 0
Ping = StatsService:WaitForChild("Network"):WaitForChild("ServerStatsItem"):WaitForChild("Data Ping")
ContextActionService = game:GetService("ContextActionService")
movedir=Vector3.new(0,0,0)
f,b,l,r = false,false,false,false
function refreshplayers()
	game:GetService("RunService").RenderStepped:Wait()

	for _,L in pairs(PLAYERLIST) do L.Tracer:Remove() L.Head:Remove() L.Nametag:Remove() L.Healthbar[1]:Remove() L.Healthbar[2]:Remove() L.Box:Remove() L.Arrow[1]:Remove() L.Arrow[2]:Remove() L.Arrow[3]:Remove() L.Arrow[4]:Remove() L.Arrow[5]:Remove() L.Arrow[6]:Remove() L.Arrow[7]:Remove() L.Arrow[8]:Remove() L.Arrow[9]:Remove() L.Arrow[10]:Remove() PLAYERLIST[_]=nil end
	local PlayerList = game:GetService("Players"):GetPlayers()
	for _,L in pairs(PlayerList) do 
		if L and L~=User then
			PLAYERLIST[L]={L,Tracer=Drawing.new("Line"),Head=Drawing.new("Circle"),Nametag=Drawing.new("Text"),Box=Drawing.new("Quad"),Healthbar={Drawing.new("Quad"),Drawing.new("Quad")},Arrow={Drawing.new("Quad"),Drawing.new("Triangle"),Drawing.new("Quad"),Drawing.new("Triangle"),Drawing.new("Quad"),Drawing.new("Quad"),Drawing.new("Quad"),Drawing.new("Quad"),Drawing.new("Quad"),Drawing.new("Quad")}} 
		end
	end
end
function randomplayer()
local temptable = game:GetService("Players"):GetPlayers()
table.remove(temptable,table.find(temptable,User))
return temptable[math.random(1,#temptable)]
end
function MatchName(Player)  ----copypasted from my other mf project, just modified it right now, it should autocomplete.... faster.
local tab = {}
		for _,player in pairs(game:GetService("Players"):GetPlayers()) do
					if tostring(player.DisplayName):lower():find(tostring(Player):lower())==1 or tostring(player.Name):lower():find(tostring(Player):lower())==1 then
						table.insert(tab,player)
					end
				end
return tab
end
WallRaycastConfig = RaycastParams.new()
WallRaycastConfig.FilterType = Enum.RaycastFilterType.Blacklist
WallRaycastConfig.IgnoreWater = true
temptgt = nil
function GetClosestPlayer(d,t,w,h,a,trackuntil)
WallRaycastConfig.FilterDescendantsInstances={Camera,UserChar}
local d = d or 25000
local player = nil

local function testfor(plr) --messy but idgaf
if plr~=User and plr.Character and UserChar then
local dist = (UserChar:GetModelCFrame().p-plr.Character:GetModelCFrame().p).Magnitude
if dist<d then else temptgt = nil end
if t then if plr.TeamColor ~= User.TeamColor then else temptgt = nil end end
if UserChar:FindFirstChildOfClass("Humanoid") then if UserChar:FindFirstChildOfClass("Humanoid").Health==0 or UserChar:FindFirstChildOfClass("Humanoid"):GetState() == Enum.HumanoidStateType.Dead then temptgt = nil end end
if a==true then if plr.Character:FindFirstChildOfClass("Humanoid") and (plr.Character:FindFirstChildOfClass("Humanoid").Health==0 or plr.Character:FindFirstChildOfClass("Humanoid"):GetState() == Enum.HumanoidStateType.Dead) then temptgt = nil else end end
if w then
local ray2 = workspace:Raycast(Camera.CFrame.p,(plr.Character:GetModelCFrame().p-Camera.CFrame.p).Unit*d,WallRaycastConfig)
local ray1 = ray2
if plr.Character:FindFirstChild("Head") then ray1 = workspace:Raycast(Camera.CFrame.p,(plr.Character:FindFirstChild("Head").CFrame.p-Camera.CFrame.p).Unit*d,WallRaycastConfig) end
if h then
if ray1==nil or ray1.Instance==nil or game:GetService("Players"):GetPlayerFromCharacter(ray1.Instance:FindFirstAncestorOfClass("Model"))==plr then else temptgt = nil end 
else
if ray2==nil or ray2.Instance==nil or game:GetService("Players"):GetPlayerFromCharacter(ray2.Instance:FindFirstAncestorOfClass("Model"))==plr then else temptgt = nil end 
end
end
player = temptgt
else
temptgt = nil
end
end

if temptgt and trackuntil then testfor(temptgt) else
for _,plr in pairs(game:GetService("Players"):GetPlayers()) do
if plr~=User and plr.Character and UserChar then
local dist = (UserChar:GetModelCFrame().p-plr.Character:GetModelCFrame().p).Magnitude
if dist<d then else continue end
if t then if plr.TeamColor ~= User.TeamColor then else continue end end
if UserChar:FindFirstChildOfClass("Humanoid") then if UserChar:FindFirstChildOfClass("Humanoid").Health==0 or UserChar:FindFirstChildOfClass("Humanoid"):GetState() == Enum.HumanoidStateType.Dead then continue end end
if a==true then if plr.Character:FindFirstChildOfClass("Humanoid") and (plr.Character:FindFirstChildOfClass("Humanoid").Health==0 or plr.Character:FindFirstChildOfClass("Humanoid"):GetState() == Enum.HumanoidStateType.Dead) then continue else end end
if w then
local ray2 = workspace:Raycast(Camera.CFrame.p,(plr.Character:GetModelCFrame().p-Camera.CFrame.p).Unit*d,WallRaycastConfig)
local ray1 = ray2
if plr.Character:FindFirstChild("Head") then ray1 = workspace:Raycast(Camera.CFrame.p,(plr.Character:FindFirstChild("Head").CFrame.p-Camera.CFrame.p).Unit*d,WallRaycastConfig) end
if h then
if ray1==nil or ray1.Instance==nil or game:GetService("Players"):GetPlayerFromCharacter(ray1.Instance:FindFirstAncestorOfClass("Model"))==plr then else continue end 
else
if ray2==nil or ray2.Instance==nil or game:GetService("Players"):GetPlayerFromCharacter(ray2.Instance:FindFirstAncestorOfClass("Model"))==plr then else continue end 
end
end
d = dist
player = plr
end
end end

temptgt = player
return player
end

refreshplayers() 
game:GetService("Players").PlayerAdded:connect(function() refreshplayers()  end)
game:GetService("Players").PlayerRemoving:connect(function() refreshplayers()  end)
local function MOVEMENT(actionname, inputstate, inputobject) --- I FUCKING HATE CONTEXTACTIONSERVICE!!!!!!!!!!!!!!!!!!!!!!!!!
	if (Config.flight or Config.verticallock) then
		if f==false and actionname == "f" and inputstate == Enum.UserInputState.Begin then f=true movedir = Vector3.new(movedir.X,movedir.Y,movedir.Z-1) end
		if b==false and actionname == "b" and inputstate == Enum.UserInputState.Begin then b=true movedir = Vector3.new(movedir.X,movedir.Y,movedir.Z+1) end
		if l==false and actionname == "l" and inputstate == Enum.UserInputState.Begin then l=true movedir = Vector3.new(movedir.X-1,movedir.Y,movedir.Z) end
		if r==false and actionname == "r" and inputstate == Enum.UserInputState.Begin then r=true movedir = Vector3.new(movedir.X+1,movedir.Y,movedir.Z) end

		if f==true and actionname == "f" and inputstate == Enum.UserInputState.End then f=false movedir = Vector3.new(movedir.X,movedir.Y,movedir.Z+1) end
		if b==true and actionname == "b" and inputstate == Enum.UserInputState.End then b=false movedir = Vector3.new(movedir.X,movedir.Y,movedir.Z-1) end
		if l==true and actionname == "l" and inputstate == Enum.UserInputState.End then l=false movedir = Vector3.new(movedir.X+1,movedir.Y,movedir.Z) end
		if r==true and actionname == "r" and inputstate == Enum.UserInputState.End then r=false movedir = Vector3.new(movedir.X-1,movedir.Y,movedir.Z) end
	end end
ContextActionService:BindAction("f", MOVEMENT, false, Enum.PlayerActions.CharacterForward)
ContextActionService:BindAction("b", MOVEMENT, false, Enum.PlayerActions.CharacterBackward)
ContextActionService:BindAction("l", MOVEMENT, false, Enum.PlayerActions.CharacterLeft)
ContextActionService:BindAction("r", MOVEMENT, false, Enum.PlayerActions.CharacterRight)
UserInputService.InputChanged:Connect(function(input, gameProcessed) if gameProcessed then movedir = Vector3.new(0,0,0) f,b,l,r = false,false,false,false  end end)---UI BUGFIX
--- Whatever else section
function flighregulate() if hr.AssemblyLinearVelocity.Magnitude>Config.fspeed/100 then hr.AssemblyLinearVelocity = Vector3.new(0,0,0) end UserChar:PivotTo(CFrame.new(UserChar:GetPivot().p)) end
game:GetService("RunService").Stepped:connect(function(a,d) ---inefficient but I think it'd be more if I spread it accross renderS and S, plus ws won't work if .RS is used
	physTPS=d or 0
	if hr and (Config.flight or Config.verticallock) and not teleportingtowardspoint then
		local movedir2 = movedir
		if movedir.Magnitude>0 then
			movedir2 = movedir.Unit 
		end
		local x, y, z, m11, m12, m13, m21, m22, m23, m31, m32, m33 = Camera.CFrame:components()
		local noycoordscam = CFrame.new(x,y,z, m11,m12,m13, m21,m22,m23, m31,0,m33)
		local ws = (Config.spd==true and Config.spdsp) or (UserHum and UserHum.WalkSpeed or 16)
		local cf = Config.verticallock==true and (noycoordscam.Rotation+Vector3.new(hr.CFrame.p.X,currentheight.Y,hr.CFrame.p.Z)):ToWorldSpace(CFrame.new(movedir2*ws/100)) or (workspace.CurrentCamera.CFrame.Rotation+hr.CFrame.p):ToWorldSpace(CFrame.new(movedir2*(Config.fspeed/10)))      --+movedir2--*(ws/1000)
		Phys:MoveTo(hr,cf,75)
	end
	if hr and not teleportingtowardspoint then if (not Config.flight and not Config.verticallock)==true then Phys:PurgePhysics(hr) end else FLYT:UpdateToggle("Flight",false) end
	if Config.FIDGETSPINNER==true and Config.fspinnernoclip==true then for _,N in pairs(UserChar:GetChildren()) do if N:IsA("BasePart") then N.CanCollide = false end end end
	if hr and Config.FIDGETSPINNER then flighregulate() if UserHum then changestatus(UserHum) end UserChar:PivotTo(CFrame.new(UserChar:GetPivot().p)) hr.AssemblyAngularVelocity = Vector3.new(0,2^16,0) end--*CFrame.Angles(0,y,0) end .6*DELTA
	if hr and Config.spd==true and Config.flight==false and UserHum then
        if UserHum.MoveDirection.Magnitude>0 then
		local ws = UserHum.MoveDirection.Unit*Config.spdsp
		hr.AssemblyLinearVelocity=Vector3.new(ws.X,hr.AssemblyLinearVelocity.Y,ws.Z) 
        elseif Config.SPEEDDRIFT==true then
		local ws = UserHum.MoveDirection.Unit*Config.spdsp
        if UserHum.MoveDirection.Magnitude>0 then
		hr.AssemblyLinearVelocity=Vector3.new(ws.X,hr.AssemblyLinearVelocity.Y,ws.Z) else
        hr.AssemblyLinearVelocity=Vector3.new(0,hr.AssemblyLinearVelocity.Y,0)
        end
        end
		--elseif hr==nil or UserHum==nil then SPDT:UpdateToggle("Enable",false) ---not really needed

	
    end
	if (Config.SWIM or Config.nograv or (Config.flightnograv and (Config.flight and not Config.verticallock)==true) or Config.FIDGETSPINNER) and hr and UserHum then --
		hr:ApplyImpulse(Vector3.new(0,hr.AssemblyMass*workspace.Gravity*d,0)) --- as precise as I can go, lots of trial and error, then it suddendly came up to me when I accidentally pressed F12.
	end 
end)

game:GetService("RunService").Heartbeat:connect(function()

if Config.superman==true and Config.FIDGETSPINNER==false and movedir.Magnitude>0 then --hr.CFrame = hr.CFrame:lerp(CFrame.new(hr.CFrame.p,cf.p),d*50) ---eh not for my taste, choppy it is!
--local cf = (workspace.CurrentCamera.CFrame.Rotation+hr.CFrame.p):ToWorldSpace(CFrame.new(movedir2*(Config.fspeed/10)))
hr.CFrame = CFrame.new(hr.CFrame.p)*CFrame.new(workspace.CurrentCamera.CFrame.p,workspace.CurrentCamera.CFrame:ToWorldSpace(CFrame.new(movedir)).p).Rotation --spawn(function() game:GetService("RunService").Heartbeat:Wait() hr.CFrame=hr.CFrame*CFrame.new(hr.CFrame.p,cf.p).Rotation end)
end

if hr and Config.FIDGETSPINNER then flighregulate() end

end)

windowactive = false
--- Rendering section
local fakemouseparams = RaycastParams.new()
fakemouseparams.IgnoreWater=false
game:GetService("RunService").RenderStepped:connect(function(D)
	local windowactive = isrbxactive()~=nil and isrbxactive() or iswindowactive()~=nil and iswindowactive
	DELTA = D
	AIMSTATUS.Text = "Aimbot: Polling"
    if Config.AIMBOT==true and (UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter and windowactive and User.GameplayPaused==false and game:GetService("GuiService").MenuIsOpen==false) or (Config.MOUSESPOOF==true and User.GameplayPaused==false and game:GetService("GuiService").MenuIsOpen==false) then 
    local target = GetClosestPlayer(25000,Config.teamcheck,Config.wallcheck,Config.headaim,true,Config.LockTarget)
	-- Adding the following later when I get home
		if target and target.Character then
        --if target.Character:FindFirstChildOfClass("Humanoid") then if target.Character:FindFirstChildOfClass("Humanoid").Health==0 or target.Character:FindFirstChildOfClass("Humanoid"):GetState() == Enum.HumanoidStateType.Dead then else
        local targetpos = nil
        if Config.headaim==true and target.Character:FindFirstChild("Head") then
        targetpos = target.Character:FindFirstChild("Head").CFrame.p
        if Config.MOUSESPOOF==true then spoofer:spoof(game:GetService("Players").LocalPlayer:GetMouse(),"Target",target.Character:FindFirstChild("Head")) end
		else targetpos = target.Character:GetModelCFrame().p 
        if Config.MOUSESPOOF==true then spoofer:spoof(game:GetService("Players").LocalPlayer:GetMouse(),"Target",target.Character:FindFirstChild("HumanoidRootPart")) end
		end
		if Config.MOUSESPOOF==true then spoofer:spoof(game:GetService("Players").LocalPlayer:GetMouse(),"Hit",CFrame.new(targetpos)) end
		--local targetpos = Vector3.new(0,0,0) --aimbot debug lol
		local FinalMouse, nigger = Camera:WorldToViewportPoint(targetpos)
		if FinalMouse.Z<0 then
		FinalMouse = math2:InverseWorldToViewportPoint(targetpos)
		end
		fakemouseparams.FilterDescendantsInstances = {Mouse.TargetFilter}
		if Config.MOUSESPOOF==true then spoofer:spoof(game:GetService("Players").LocalPlayer:GetMouse(),"UnitRay",workspace:Raycast(workspace.CurrentCamera.CFrame.p,(targetpos-workspace.CurrentCamera.CFrame.p).Unit,fakemouseparams)) spoofer:spoof(game:GetService("Players").LocalPlayer:GetMouse(),"Origin",CFrame.new(workspace.CurrentCamera.CFrame.p,targetpos)) end
		local Move = (((Vector2.new(FinalMouse.X-Mouse.X,FinalMouse.Y-Mouse.Y-inset))/UserSettings():GetService("UserGameSettings").MouseSensitivity)/UserInputService.MouseDeltaSensitivity)*0.01
        Move = FinalMouse.Z<0 and Move*Config.aimspeed*D*.6 or Move*Config.aimspeed --- I don't know why but 60*DeltaT works? Bruh: https://developer.roblox.com/en-us/articles/CFrame-Math-Operations
        if target.Character:FindFirstChildOfClass("Humanoid") and (target.Character:FindFirstChildOfClass("Humanoid").Health==0 or target.Character:FindFirstChildOfClass("Humanoid"):GetState() == Enum.HumanoidStateType.Dead) then else if Config.MOUSESPOOF==true then else mousemoverel(Move.X,Move.Y) end AIMSTATUS.Text = "Aimbot: Aiming" if Config.TRIGGERBOT==true then if math.abs(((FinalMouse.X-Mouse.X+FinalMouse.Y-Mouse.Y-inset)/2)/FinalMouse.Z) <=math.abs((Resolution.Y*(Config.shootrad/Resolution.Y))/FinalMouse.Z) or Config.MOUSESPOOF then spawn(function() if FIRING==false then mouse1press() AIMSTATUS2.Text = " ["..(1/Config.firedelay).." Clicks per second]" FIRING = true wait(Config.firedelay) mouse1release() AIMSTATUS2.Text = "" FIRING = false  end end) end end end     
    end
	
    end
	for _,N in pairs(PLAYERLIST) do
		local Plr = _
		local Box = N.Box
		local Arrow = N.Arrow
		local Healthbar = N.Healthbar
		local Char = Plr.Character
        local HeadE = N.Head
        local NameTag = N.Nametag
        local Tracer = N.Tracer
        local Head = nil
		if Config.ESP==true and Char and Box and Arrow[10] and Healthbar[2] and NameTag and HeadE and (Char:GetModelCFrame().p-Camera.CFrame.p).Magnitude<=25000 and workspace.CurrentCamera.CameraSubject ~= Char and workspace.CurrentCamera.CameraSubject ~= Char:FindFirstChildOfClass("Humanoid") then --- hard limit lol
            local Head = Char:FindFirstChild("Head")
			local Hum = Char:FindFirstChildOfClass("Humanoid")
			local Pos,Size = GetBoundingBox(Char,false,Char:GetModelCFrame())--Char:GetExtentsSize() --- the new method kills ur fps but is MUCH CLEANER. --- Removed some unnecessary vars and performance hit compared to older methods is now MINIMAL. HOORAY!!!!
            local teamcolor = Config.COLOREDBOXES and Plr.TeamColor.Color:Lerp(Color3.new(1,1,1),.5) or Color3.new(1,1,1)


			local UR,V1 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X,Size.Y,0)/2))
			local UL,V2 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X,Size.Y,0)/2))
			local DL,V3 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X,-Size.Y,0)/2))
			local DR,V4 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X,-Size.Y,0)/2))

			Box.PointA = Vector2.new(UR.X,UR.Y)
			Box.PointB = Vector2.new(UL.X,UL.Y)
			Box.PointC = Vector2.new(DL.X,DL.Y)
			Box.PointD = Vector2.new(DR.X,DR.Y)

			--- these above are for the directional arrow



			local BUR,V19 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/1.65,Size.Y/2,0)))
			local BUL,V20 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/2,Size.Y/2,0)))
			local BDL,V21 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/2,-Size.Y/2,0)))
			local BDR,V22 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/1.65,-Size.Y/2,0)))

			local H1,H2 = 0,0

			if Hum then
				local healthperone = (Hum.Health/Hum.MaxHealth)
				--if Hum.Health==0 or Hum:GetState() == Enum.HumanoidStateType.Dead then healthperone=0 end
				local barh = -Size.Y/2+(Size.Y)*healthperone
				H1 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/1.65,barh,0)))
				H2 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/2,barh,0)))
				Healthbar[2].Color = Color3.fromHSV(healthperone*.3,0.8,1)
			else
				H1 = BDL
				H2 = BDR
			end

			Healthbar[1].PointA = Vector2.new(BUR.X,BUR.Y)
			Healthbar[1].PointB = Vector2.new(BUL.X,BUL.Y)
			Healthbar[1].PointC = Vector2.new(BDL.X,BDL.Y)
			Healthbar[1].PointD = Vector2.new(BDR.X,BDR.Y)

			Healthbar[2].PointA = Vector2.new(H1.X,H1.Y)
			Healthbar[2].PointB = Vector2.new(H2.X,H2.Y)
			Healthbar[2].PointC = Vector2.new(BDL.X,BDL.Y)
			Healthbar[2].PointD = Vector2.new(BDR.X,BDR.Y)

			--- healthbar logic above


			Box.Filled = false

			Box.Thickness = ((0.068*Resolution.Y)/(Camera.CFrame.p-(Pos.p+Vector3.new(0,Size.Y,0))).Magnitude)*(70/Camera.FieldOfView)
			Box.Color = teamcolor
			Box.ZIndex = lowvalue+2



			Healthbar[1].Filled = true
			Healthbar[1].ZIndex = Box.ZIndex+1
			Healthbar[1].Color = Color3.new(0,0,0)
			Healthbar[1].Thickness = 0--Box.Thickness

			Healthbar[2].Filled = true
			Healthbar[2].ZIndex = Healthbar[1].ZIndex+1
			Healthbar[2].Thickness = 0
            ------------
            local UR,UL,DL,DR,L,R,U,UR2,UL2,DL2,DR2,L2,U2,R2,V5,V6,V7,V8,V9,V10,V11,V12,V13,V14,V15,V16,V17,V18 = nil --- these are literally every fucking variable for the fucking arrows. Really resource intensive.
            if Config.ARW==true then


            UR,V5 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/8,Size.Y,0)))
			UL,V6 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/8,Size.Y,0)))
			DL,V7 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/8,Size.Y,Size.X/2)))
			DR,V8 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/8,Size.Y,Size.X/2)))

			Arrow[1].PointA = Vector2.new(UR.X,UR.Y)
			Arrow[1].PointB = Vector2.new(UL.X,UL.Y)
			Arrow[1].PointC = Vector2.new(DL.X,DL.Y)
			Arrow[1].PointD = Vector2.new(DR.X,DR.Y)

			L,V9 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/4,Size.Y,0)))
			R,V10 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/4,Size.Y,0)))
			U,V11 = Camera:WorldToViewportPoint(Pos*(Vector3.new(0,Size.Y,-Size.X/2)))

			Arrow[2].PointA = Vector2.new(U.X,U.Y)
			Arrow[2].PointB = Vector2.new(L.X,L.Y)
			Arrow[2].PointC = Vector2.new(R.X,R.Y)

			UR2,V12 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/8,Size.Y+Size.X/5,0)))
			UL2,V13 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/8,Size.Y+Size.X/5,0)))
			DL2,V14 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/8,Size.Y+Size.X/5,Size.X/2)))
			DR2,V15 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/8,Size.Y+Size.X/5,Size.X/2)))

			Arrow[3].PointA = Vector2.new(UR2.X,UR2.Y)
			Arrow[3].PointB = Vector2.new(UL2.X,UL2.Y)
			Arrow[3].PointC = Vector2.new(DL2.X,DL2.Y)
			Arrow[3].PointD = Vector2.new(DR2.X,DR2.Y)

			L2,V16 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/4,Size.Y+Size.X/5,0)))
			R2,V17 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/4,Size.Y+Size.X/5,0)))
			U2,V18 = Camera:WorldToViewportPoint(Pos*(Vector3.new(0,Size.Y+Size.X/5,-Size.X/2)))

			Arrow[4].PointA = Vector2.new(U2.X,U2.Y)
			Arrow[4].PointB = Vector2.new(L2.X,L2.Y)
			Arrow[4].PointC = Vector2.new(R2.X,R2.Y)


            Arrow[1].Filled = true
			Arrow[2].Filled = Arrow[1].Filled
			Arrow[3].Filled = Arrow[1].Filled
			Arrow[4].Filled = Arrow[1].Filled
			Arrow[5].Filled = Arrow[1].Filled
			Arrow[6].Filled = Arrow[1].Filled
			Arrow[7].Filled = Arrow[1].Filled
			Arrow[8].Filled = Arrow[1].Filled
			Arrow[9].Filled = Arrow[1].Filled
			Arrow[10].Filled = Arrow[1].Filled

			Arrow[1].Transparency = 0.25
			Arrow[2].Transparency = Arrow[1].Transparency
			Arrow[3].Transparency = Arrow[1].Transparency
			Arrow[4].Transparency = Arrow[1].Transparency
			Arrow[5].Transparency = Arrow[1].Transparency
			Arrow[6].Transparency = Arrow[1].Transparency
			Arrow[7].Transparency = Arrow[1].Transparency
			Arrow[8].Transparency = Arrow[1].Transparency
			Arrow[9].Transparency = Arrow[1].Transparency
			Arrow[10].Transparency = Arrow[1].Transparency

			Arrow[1].Thickness = 0 --(0.06*Resolution.Y)/(Camera.CFrame.p-(Pos.p+Vector3.new(0,Size.Y,0))).Magnitude
			Arrow[1].Color = teamcolor
			Arrow[1].ZIndex = Box.ZIndex+3

			Arrow[2].Thickness = Arrow[1].Thickness*2
			Arrow[2].Color = Arrow[1].Color
			Arrow[2].ZIndex = Arrow[1].ZIndex

			Arrow[3].Thickness = Arrow[1].Thickness
			Arrow[3].Color = Arrow[1].Color
			Arrow[3].ZIndex = Arrow[1].ZIndex

			Arrow[4].Thickness = Arrow[1].Thickness*2
			Arrow[4].Color = Arrow[1].Color
			Arrow[4].ZIndex = Arrow[1].ZIndex

			Arrow[5].Thickness = Arrow[1].Thickness
			Arrow[5].Color = Arrow[1].Color
			Arrow[5].ZIndex = Arrow[1].ZIndex
			Arrow[5].PointA = Vector2.new(U2.X,U2.Y)
			Arrow[5].PointB = Vector2.new(R2.X,R2.Y)
			Arrow[5].PointC = Vector2.new(R.X,R.Y)
			Arrow[5].PointD = Vector2.new(U.X,U.Y)

			Arrow[6].Thickness = Arrow[1].Thickness
			Arrow[6].Color = Arrow[1].Color
			Arrow[6].ZIndex = Arrow[1].ZIndex
			Arrow[6].PointA = Vector2.new(U2.X,U2.Y)
			Arrow[6].PointB = Vector2.new(L2.X,L2.Y)
			Arrow[6].PointC = Vector2.new(L.X,L.Y)
			Arrow[6].PointD = Vector2.new(U.X,U.Y)

			Arrow[7].Thickness = Arrow[1].Thickness
			Arrow[7].Color = Arrow[1].Color
			Arrow[7].ZIndex = Arrow[1].ZIndex
			Arrow[7].PointA = Vector2.new(R2.X,R2.Y)
			Arrow[7].PointB = Vector2.new(L2.X,L2.Y)
			Arrow[7].PointC = Vector2.new(L.X,L.Y)
			Arrow[7].PointD = Vector2.new(R.X,R.Y)

			Arrow[8].Thickness = Arrow[1].Thickness
			Arrow[8].Color = Arrow[1].Color
			Arrow[8].ZIndex = Arrow[1].ZIndex
			Arrow[8].PointA = Vector2.new(UR2.X,UR2.Y)
			Arrow[8].PointB = Vector2.new(DR2.X,DR2.Y)
			Arrow[8].PointC = Vector2.new(DR.X,DR.Y)
			Arrow[8].PointD = Vector2.new(UR.X,UR.Y)

			Arrow[9].Thickness = Arrow[1].Thickness
			Arrow[9].Color = Arrow[1].Color
			Arrow[9].ZIndex = Arrow[1].ZIndex
			Arrow[9].PointA = Vector2.new(UL2.X,UL2.Y)
			Arrow[9].PointB = Vector2.new(DL2.X,DL2.Y)
			Arrow[9].PointC = Vector2.new(DL.X,DL.Y)
			Arrow[9].PointD = Vector2.new(UL.X,UL.Y)

			Arrow[10].Thickness = Arrow[1].Thickness
			Arrow[10].Color = Arrow[1].Color
			Arrow[10].ZIndex = Arrow[1].ZIndex
			Arrow[10].PointA = Vector2.new(DR2.X,DR2.Y)
			Arrow[10].PointB = Vector2.new(DL2.X,DL2.Y)
			Arrow[10].PointC = Vector2.new(DL.X,DL.Y)
			Arrow[10].PointD = Vector2.new(DR.X,DR.Y)
            end
            local HPV,HPV2 = nil
            HeadE.Visible = false
            if Head and Head:IsA("BasePart") then
            local avghead = (Head.Size.X+Head.Size.Y+Head.Size.Z)/3
            HPV,HPV2 = Camera:WorldToViewportPoint(Head.CFrame.p)
            HeadE.Position = Vector2.new(HPV.X,HPV.Y)
            HeadE.Radius = ((Resolution.Y*0.4*avghead)/HPV.Z)*(70/Camera.FieldOfView)
            HeadE.Thickness = ((Resolution.Y*0.2*avghead)/HPV.Z)*(70/Camera.FieldOfView)
            HeadE.Color = teamcolor
            HeadE.Transparency = math.clamp((Head.CFrame.p-Camera.CFrame.p).Magnitude-1,0,1)
            HeadE.ZIndex = lowvalue+1
            end
            local NT,NT2 = Camera:WorldToViewportPoint(Pos*Vector3.new(0,(Size.Y*Config.NTAGSV/100),0)) --workspace.CurrentCamera.CFrame.p-Char:GetModelCFrame().p).Magnitude
            NameTag.Size = math.clamp((Resolution.Y*(Config.NTAGV/500))*(70/120),24,math.huge) --24
            NameTag.Position = Vector2.new(NT.X,NT.Y-NameTag.TextBounds.Y/2)
            NameTag.Text = Plr.Team and Plr.DisplayName.."/"..Plr.Name.."  ["..tostring(Plr.Team).."]" or Plr.DisplayName.."/"..Plr.Name
            NameTag.Center = true
            NameTag.Color = Box.Color
            NameTag.Font = Config.FONT
            local TT = Camera:WorldToViewportPoint(Pos*Vector3.new(0,-Size.Y/2,0))
            Tracer.Thickness = (Resolution.Y*0.0016)
            Tracer.Color = Box.Color
            Tracer.Transparency = math.clamp(1-(Pos.p-Camera.CFrame.p).Magnitude/423,.32,1)
            Tracer.From = Vector2.new(Resolution.X/2,Resolution.Y*0.95)
            Tracer.ZIndex = Box.ZIndex+4
        
            --local PlrCameraOffset = Camera.CFrame:PointToObjectSpace(Pos.p) -- could be useful later for aimbot
            if TT.Z<0 then
            --[[local PlrCameraOffset = Camera.CFrame:PointToObjectSpace(Pos*Vector3.new(0,-Size.Y/2,0))
            local AT = math.atan2(PlrCameraOffset.Y, PlrCameraOffset.X) + math.pi;
            local inverse = CFrame.Angles(0, 0, AT):vectorToWorldSpace((CFrame.Angles(0, math.rad(89.9), 0):vectorToWorldSpace(Vector3.new(0, 0, -1)))); --- my brain too ooga booga for this shit
            TT,TT2 = Camera:WorldToViewportPoint(Camera.CFrame:pointToWorldSpace(inverse))]]
			TT=math2:InverseWorldToViewportPoint(Pos*Vector3.new(0,-Size.Y/2,0))
            end
            Tracer.To = Vector2.new(TT.X,TT.Y)
            if Config.TRACERST==true then Tracer.Visible = Config.ESP else Tracer.Visible = false end
            if NT2 and Config.NTAGST==true then NameTag.Visible = Config.ESP else NameTag.Visible = false end
            if HPV2 and Config.HESPT==true then HeadE.Visible = Config.ESP else HeadE.Visible = false end
            if Config.ARW==true and V5 and V6 and V7 and V8 and V9 and V10 and V11 and V12 and V13 and V14 and V15 and V16 and V17 and V18 then Arrow[1].Visible = Config.ESP Arrow[2].Visible = Config.ESP Arrow[3].Visible = Config.ESP Arrow[4].Visible = Config.ESP Arrow[5].Visible = Config.ESP Arrow[6].Visible = Config.ESP Arrow[7].Visible = Config.ESP Arrow[8].Visible = Config.ESP Arrow[9].Visible = Config.ESP Arrow[10].Visible = Config.ESP else Arrow[1].Visible = false Arrow[2].Visible = false Arrow[3].Visible = false Arrow[4].Visible = false Arrow[5].Visible = false Arrow[6].Visible = false Arrow[7].Visible = false Arrow[8].Visible = false Arrow[9].Visible = false Arrow[10].Visible = false end
			if Config.HLT==true and V19 and V20 and V21 and V22 then Healthbar[1].Visible = Config.ESP Healthbar[2].Visible = Config.ESP else Healthbar[1].Visible = false Healthbar[2].Visible = false end
			if V1 and V2 and V3 and V4 then Box.Visible = Config.ESP else Box.Visible = false end
		else NameTag.Visible = false Tracer.Visible = false HeadE.Visible = false Box.Visible = false Arrow[1].Visible = false Arrow[2].Visible = false Arrow[3].Visible = false Arrow[4].Visible = false Arrow[5].Visible = false Arrow[6].Visible = false Arrow[7].Visible = false Arrow[8].Visible = false Arrow[9].Visible = false Arrow[10].Visible = false Healthbar[1].Visible = false Healthbar[2].Visible = false end
	end
    --[[for _,waypoint in pairs(Waypoints) do
  
    end]]
end)

--[[
					local ScreenPosition, Vis = WorldToViewport(v.Instance.Position);
					local Color = v.Color;
					local OPos = Camera.CFrame:pointToObjectSpace(v.Instance.Position);
					
					if ScreenPosition.Z < 0 then
						local AT = math.atan2(OPos.Y, OPos.X) + math.pi;
						OPos = CFrame.Angles(0, 0, AT):vectorToWorldSpace((CFrame.Angles(0, math.rad(89.9), 0):vectorToWorldSpace(V3New(0, 0, -1))));
					end


]] -- This is some code yoinked from unnamed esp
---

function updatetoggles(config)
ESPTOG:UpdateToggle("ESP",config.ESP)

CROSSTOG:UpdateToggle("Crosshair",config.CROSS)

XRAYTOG:UpdateToggle("X-Ray",config.XRAYB)

FOVTOG:UpdateToggle("FOV",config.FOVSET)

SPDT:UpdateToggle("Walkspeed",config.spd)

FLYT:UpdateToggle("Flight",config.flight)

VLOCKTOG:UpdateToggle("Vertical lock",config.verticallock)

CLICKTPT:UpdateToggle("Click teleport",config.CLICKTPTOG)

CLICKDELT:UpdateToggle("Click 'delete'",config.CLICKDELTOG)

AIMBOTTOG:UpdateToggle("Aimbot",config.AIMBOT)

triggerbottog:UpdateToggle("Triggerbot",config.TRIGGERBOT)

mousespooftog:UpdateToggle("Silent Aim",config.MOUSESPOOF)

AUTOWALKTOG:UpdateToggle("Auto walk",config.autowalk)

MTOG:UpdateToggle("Disable death",config.IMMORTALITY)

FELOOPPROTTOG:UpdateToggle("Anti feloop",config.AFELOOP)

FPDST:UpdateToggle("Ignore destruction layer",config.FPDSD)

FidgetSpinner:UpdateToggle("Fidget spinner",config.FIDGETSPINNER)

FIDGETSPINNERNOCLIP:UpdateToggle("Fidget spinner noclip",config.fspinnernoclip)

swmT:UpdateToggle("Air swim",config.SWIM)

NOGRAV:UpdateToggle("No gravity",config.nograv)

TEAMCOLOREDBOXt:UpdateToggle("Team coloured boxes",config.COLOREDBOXES)

mn:UpdateToggle("Directional Arrows",config.ARW)

mn2:UpdateToggle("Healthbar",config.HLT)

HESP:UpdateToggle("Show heads",config.HESPT)

TRACERS:UpdateToggle("Tracers",config.TRACERST)

NTAG:UpdateToggle("Nametags",config.NTAGST)

AUTOUPDXRAY:UpdateToggle("X-Ray autoupdate",config.XRAYBU)

SUPRMN:UpdateToggle("Superman mockup",config.superman)

FLIGHTNOGRAV:UpdateToggle("Anti flight drift",config.flightnograv)

SPDDRFT:UpdateToggle("Anti slip",config.SPEEDDRIFT)

ANTIANTITPt:UpdateToggle("Anti anti tp",config.antiantitp)

TEAMCHECK:UpdateToggle("Team check",config.teamcheck)

WALLCHECK:UpdateToggle("Wall check",config.wallcheck)

HEADAIM:UpdateToggle("Headshot",config.headaim)

RANDOMTARGETTOGGLE:UpdateToggle("Random target",config.RANDOMTGT)

LOCKTARGETTOG:UpdateToggle("Lock target",config.LockTarget)
end

local configtab = Settings:NewSection("Configuration")
configtab:NewButton("Overwrite config", "game:GetService('HttpService'):JSONDecode(readfile('X-PL0X.xplx'))", function()
if writefile then else return end
writefile("X-PL0X.xplx",game:GetService("HttpService"):JSONEncode(Config))
game:GetService("StarterGui"):SetCore("SendNotification",Notifications.Overwrite)
end)
configtab:NewButton("Load config", "writefile('X-PL0X.xplx',game:GetService('HttpService'):JSONEncode(Config))", function()
if pcall(function() readfile("X-PL0X.xplx") end) then else return end
if readfile then else return end
updatetoggles(game:GetService("HttpService"):JSONDecode(readfile("X-PL0X.xplx")))
Config = game:GetService("HttpService"):JSONDecode(readfile("X-PL0X.xplx"))
game:GetService("StarterGui"):SetCore("SendNotification",Notifications.Read)
end)

if readfile and writefile then
if pcall(function() readfile("X-PL0X.xplx") end) then
updatetoggles(game:GetService("HttpService"):JSONDecode(readfile("X-PL0X.xplx")))
Config = game:GetService("HttpService"):JSONDecode(readfile("X-PL0X.xplx"))
game:GetService("StarterGui"):SetCore("SendNotification",Notifications.Read)
else
writefile("X-PL0X.xplx",game:GetService("HttpService"):JSONEncode(Config))
game:GetService("StarterGui"):SetCore("SendNotification",Notifications.Overwrite)
end
end



physTPS = 0
spawn(function() --- Pathfinding function
end)
while wait(.5) do  --- this is for a more readable stat sheet
	PINGL:UpdateLabel("Ping: "..string.split(Ping:GetValueString()," ")[1].."ms")
	FPSL:UpdateLabel("FPS: "..math2.round(1/DELTA,2)) --ez fps and rounding
	TPSL:UpdateLabel("Tasks per second: "..1/(StatsService.HeartbeatTimeMs/1000))
	PTPSL:UpdateLabel("Physics iterations per second: "..1/(StatsService.PhysicsStepTimeMs/1000))
	PhysL:UpdateLabel("Phys TPS: "..workspace:GetRealPhysicsFPS())
	PhysLR:UpdateLabel("True Phys TPS: "..tonumber(1/physTPS))
end

--GUI:MakeBox(500,500,200,100,true,0,Color3.new(255,255,255))
--[[local throwawaytable = {true,false} -- Gay ass table that i don't need
while true do
	local poop = GUI:MakeBox(math.random(0,Resolution.X),math.random(0,Resolution.Y),math.random(0,Resolution.X),math.random(0,Resolution.Y),throwawaytable[math.random(1,#throwawaytable)],math.random(0,10),Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))) -- generate random box with random properties
    wait(1)
    table.remove(GUIFRAMES,table.find(GUIFRAMES,poop))
	poop:Remove()
end]] --- Refraining from using drawing api for objects and shit. LITERALLY TOO MUCH TROUBLE FOR ITS WORTH.