--GUI = loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/drawinglib.lua')()
repeat wait() until Drawing
if getgenv().XPL0X and not devmode then return end
getgenv().XPL0X = true
local WAITBACKGROUND = Drawing.new("Quad")
local WAITMSG = Drawing.new("Text")
local ASSETCOUNT = Drawing.new("Text")
CR1=Drawing.new("Line")
CR2=Drawing.new("Line")
AIMSTATUS=Drawing.new("Text")
AIMSTATUS2=Drawing.new("Text")
PATHSTATUS=Drawing.new("Text")
FONT = 0
--- warn(UserSettings():GetService("UserGameSettings").MouseSensitivity) this'll come in handy later.


if game:IsLoaded() then else  ---- In case game didn't load leave out a nice ass message like this
	repeat game:GetService("RunService").RenderStepped:Wait() 
		WAITMSG.Center = true 
		WAITMSG.Visible = true
		WAITMSG.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X/2,workspace.CurrentCamera.ViewportSize.Y/3)
		WAITMSG.Size = workspace.CurrentCamera.ViewportSize.Y/workspace.CurrentCamera.ViewportSize.X/10
		WAITMSG.Text = "Yo nigga the game hasn't loaded yet"
		WAITMSG.Color = Color3.new(1,1,1)
		WAITMSG.OutlineColor = Color3.new(0,0,0)
		WAITMSG.Outline = true
		WAITMSG.Font = FONT
		WAITBACKGROUND.Visible = true
		WAITBACKGROUND.PointA = Vector2.new(workspace.CurrentCamera.ViewportSize.X,0)
		WAITBACKGROUND.PointB = Vector2.new(0,0)
		WAITBACKGROUND.PointC = Vector2.new(0,workspace.CurrentCamera.ViewportSize.Y)
		WAITBACKGROUND.PointD = Vector2.new(workspace.CurrentCamera.ViewportSize.X,workspace.CurrentCamera.ViewportSize.Y)
		WAITBACKGROUND.Color = Color3.new(1,1,1)
		WAITBACKGROUND.Transparency = 1
		WAITBACKGROUND.Filled = true
		ASSETCOUNT.Size = WAITMSG.Size*0.8
		ASSETCOUNT.Position = Vector2.new(WAITMSG.Position.X,WAITMSG.Position.Y+WAITMSG.TextBounds.Y)
		ASSETCOUNT.Text = "Brought to you by hicksville (real)"
		ASSETCOUNT.OutlineColor = Color3.new(0,0,0)
		ASSETCOUNT.Color = Color3.new(1,1,1)
		ASSETCOUNT.Center = true
		ASSETCOUNT.Visible = true
		ASSETCOUNT.Outline = true
		ASSETCOUNT.Font = FONT
	until game.Loaded
end

function GetBoundingBox(model, recursive, orientation) ----- copypasted code xdflol
	if typeof(model) == "Instance" then
		model = recursive and model:GetDescendants() or model:GetChildren()
	end
	if not orientation then
		orientation = CFrame.new()
	end

	local minx, miny, minz = math.huge,math.huge,math.huge
	local maxx, maxy, maxz = -math.huge,-math.huge,-math.huge

	for _, obj in pairs(model) do
		if obj:IsA("BasePart") then
			local cf = obj.CFrame
			cf = orientation:toObjectSpace(cf)
			local size = obj.Size
			local sx, sy, sz = size.X, size.Y, size.Z

			local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cf:components()

			local wsx = 0.5 * (math.abs(R00) * sx + math.abs(R01) * sy + math.abs(R02) * sz)
			local wsy = 0.5 * (math.abs(R10) * sx + math.abs(R11) * sy + math.abs(R12) * sz)
			local wsz = 0.5 * (math.abs(R20) * sx + math.abs(R21) * sy + math.abs(R22) * sz)

			if minx > x - wsx then
				minx = x - wsx
			end
			if miny > y - wsy then
				miny = y - wsy
			end
			if minz > z - wsz then
				minz = z - wsz
			end

			if maxx < x + wsx then
				maxx = x + wsx
			end
			if maxy < y + wsy then
				maxy = y + wsy
			end
			if maxz < z + wsz then
				maxz = z + wsz
			end
		end
	end

	local omin, omax = Vector3.new(minx, miny, minz), Vector3.new(maxx, maxy, maxz)
	local omiddle = (omax+omin)/2
	local wCf = orientation - orientation.p + orientation:pointToWorldSpace(omiddle)
	local size = (omax-omin)
	return wCf, size
end

Phys = devmode and loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/dev/libraries/physicsMANIPULATOR.lua')() or loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/physicsMANIPULATOR.lua')()
Gaylib = devmode and loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/dev/libraries/Kavo.lua')() or loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/Kavo.lua')()
math2 = devmode and loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/dev/libraries/arbitrarymath.lua')() or loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/arbitrarymath.lua')()
spoofer = devmode and loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/dev/libraries/metatableMANIPULATOR.lua')() or loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/metatableMANIPULATOR.lua')()

repeat wait() until game:GetService('Players').LocalPlayer
repeat wait() until workspace.CurrentCamera
WAITBACKGROUND:Remove()
WAITMSG:Remove()
ASSETCOUNT:Remove()
User = game:GetService('Players').LocalPlayer
Mouse = User:GetMouse()
UserChar,UserHum,hr=nil
SUPERMANN=nil
Rig=nil
inset = 36
SUPERMAN = Instance.new("Animation")
SUPERMAN.AnimationId="http://www.roblox.com/asset/?id=616115533"  ---superman animation???? god muddafuggin dam!!!!
SUPERMANR6 = Instance.new("Animation")
SUPERMANR6.AnimationId = "rbxassetid://429681631"  ---superman animation for r6???? god muddafuggin dam!!!!
ARW = false
HLT = true
function changestatus(h) --- I guess this is how I'll set up humanoid status changes from now on
	if IMMORTALITY and h then h:SetStateEnabled(15,false) end --my dumb ass thought this was somewhere else
	if SWIM and h then h:ChangeState(4) end
	if flight and h then h:ChangeState(5) end
	if FIDGETSPINNER and h then h:ChangeState(8) end
end
function XRAY(int)
local int = tonumber(int) or 0
local function search(obj)
if obj:IsA("BasePart") then obj.LocalTransparencyModifier = math.abs(int) end
if obj:FindFirstChildOfClass("Humanoid") then return end
for _,l in pairs (obj:GetChildren()) do
search(l)
end
end
search(workspace)
end

function charinstanceaddedfunc(l,h)
if AFELOOP and l and l:IsA("Tool") and h then
game:GetService("RunService").Stepped:Wait()
UserHum:UnequipTools()
end
end

AllocatedPath = game:GetService("PathfindingService"):CreatePath({AgentRadius=0,AgentHeight = math.huge,AgentCanJump = true}) --- The 'weird first two parameters' are necessary in this case.
Waypoints = {}
PathState = nil

function findpath(From,To,Path)
local from = From
local to = To
local path = Path
if from and to and path then else return nil end
if typeof(from) == "CFrame" then from = from.p end
if typeof(to) == "CFrame" then to = to.p end
	local success, errorMessage = pcall(function()
		path:ComputeAsync(from,to)
	end)
	if success then
    PathState = path.Status Waypoints = path:GetWaypoints()--return path.Status,path:GetWaypoints() --- lol fuck this gay poop thing let's just replace a table
	else PathState = nil Waypoints = {} --return nil,tostring(errorMessage) 
	end
end


if UserChar and UserHum and hr and UserHead then else
	if humanoidstatuschanger then humanoidstatuschanger:Disconnect() end
    if CharInstanceAddedFunc then CharInstanceAddedFunc:Disconnect() end
	spawn(function()
		repeat wait() until User.Character
		UserChar = User.Character
        if UserChar:FindFirstChild("Head") and UserChar:FindFirstChild("Head"):IsA("BasePart") then UserHead = UserChar:FindFirstChild("Head") end
        CharInstanceAddedFunc = UserChar.ChildAdded:connect(function(s) charinstanceaddedfunc(s,UserHum) end)
		if UserChar:FindFirstChildOfClass("Humanoid") then UserHum=UserChar:FindFirstChildOfClass("Humanoid") hr = UserHum.RootPart Rig = UserHum.RigType humanoidstatuschanger = UserHum.StateChanged:connect(function() changestatus(UserHum) end) end
		spawn(function() while UserHum==nil do wait() end
			if UserHum and UserHum.RigType == Enum.HumanoidRigType.R15 then
				SUPERMANN = UserHum:LoadAnimation(SUPERMAN) SUPERMANN.Priority = Enum.AnimationPriority.Action SUPERMANN.TimePosition = 1 SUPERMANN.Looped = true
			elseif UserHum then
				SUPERMANN = UserHum:LoadAnimation(SUPERMANR6) SUPERMANN.Priority = Enum.AnimationPriority.Action SUPERMANN.TimePosition = .09 SUPERMANN.Looped = true
			end
			changestatus(UserHum)
		end)
	end)
end

User.CharacterAdded:connect(function(nig)
	if humanoidstatuschanger then humanoidstatuschanger:Disconnect() end
    if CharInstanceAddedFunc then CharInstanceAddedFunc:Disconnect() end
	UserChar = nig
    CharInstanceAddedFunc = UserChar.ChildAdded:connect(function(s) charinstanceaddedfunc(s,UserHum) end)
	SUPERMANN = nil
	UserHum=UserChar:FindFirstChildOfClass("Humanoid")
    if UserChar:FindFirstChild("Head") and UserChar:FindFirstChild("Head"):IsA("BasePart") then UserHead = UserChar:FindFirstChild("Head") end
	spawn(function()
		repeat wait() until User.Character and User.Character:FindFirstChildOfClass("Humanoid")
		UserHum=UserChar:FindFirstChildOfClass("Humanoid") 
        hr = UserHum.RootPart
		humanoidstatuschanger = UserHum.StateChanged:connect(function() changestatus(UserHum) end)
		Rig = UserHum.RigType
		if User.Character:FindFirstChildOfClass("Humanoid") and User.Character:FindFirstChildOfClass("Humanoid").RigType == Enum.HumanoidRigType.R15 then
			SUPERMANN = User.Character:FindFirstChildOfClass("Humanoid"):LoadAnimation(SUPERMAN) SUPERMANN.Priority = Enum.AnimationPriority.Action SUPERMANN.TimePosition = 1 SUPERMANN.Looped = true if flight and superman then SUPERMANN:Play(.1,1,0) end 
		elseif User.Character:FindFirstChildOfClass("Humanoid") then
			SUPERMANN = User.Character:FindFirstChildOfClass("Humanoid"):LoadAnimation(SUPERMANR6) SUPERMANN.Priority = Enum.AnimationPriority.Action SUPERMANN.TimePosition = .09 SUPERMANN.Looped = true if flight and superman then SUPERMANN:Play(.1,1,0) end
		end
		changestatus(UserHum)
	end)
end) 
--- Thank you xHeptc for making the super duper sexy nigger gui lib
game:GetService("RunService").RenderStepped:connect(function() -- Constant updater to ease up resource use
	Camera = workspace.CurrentCamera
	Resolution = Vector2.new(Mouse.ViewSizeX,Mouse.ViewSizeY)
	if SUPERMANN then
		if Rig == Enum.HumanoidRigType.R15 then
			SUPERMANN.Priority = Enum.AnimationPriority.Action
			SUPERMANN.TimePosition = 1
			SUPERMANN.Looped = true
		else
			SUPERMANN.Priority = Enum.AnimationPriority.Action 
			SUPERMANN.TimePosition = .12 
			SUPERMANN.Looped = true
		end
		if CROSS then
			CR1.Visible = true
			CR2.Visible = true
			local maths = (Resolution.Y*(math.abs(CROSSS)/1000))
			CR1.From = Vector2.new(Mouse.X-maths,Mouse.Y+inset)
			CR1.To = Vector2.new(Mouse.X+maths,Mouse.Y+inset)
			CR1.Thickness = (Resolution.Y*.0025)
			CR2.From = Vector2.new(Mouse.X,Mouse.Y+inset+maths)
			CR2.To = Vector2.new(Mouse.X,Mouse.Y+inset-maths)
			CR2.Thickness = (Resolution.Y*.0025)
			CR1.Color = CROSSC
			CR2.Color = CROSSC
			CR1.ZIndex = lowvalue
			CR2.ZIndex = lowvalue
            if CROSSTRAN then
            CR1.Transparency = CROSSTRAN/100 else CR1.Transparency = 1 end
            CR2.Transparency = CR1.Transparency
		else
			CR1.Visible = false
			CR2.Visible = false
		end
		if AIMBOT and game:GetService("GuiService").MenuIsOpen==false then 
			AIMSTATUS.Visible=true
			AIMSTATUS.Font = FONT
			AIMSTATUS.Color = CROSS and CR1.Color:Lerp(Color3.new(1,1,1),.5) or Color3.new(1,1,1)
			AIMSTATUS.OutlineColor = Color3.new(0,0,0)
			AIMSTATUS.Transparency = CROSS and CROSSTRAN and CROSSTRAN/100 or 0
			AIMSTATUS.Size = Resolution.Y*0.03
			AIMSTATUS.Center = true
			AIMSTATUS.Position = Vector2.new(Mouse.X+AIMSTATUS.TextBounds.X/1.5,Mouse.Y+inset-AIMSTATUS.TextBounds.Y)

			AIMSTATUS2.Visible=AIMSTATUS.Visible
			AIMSTATUS2.Font = AIMSTATUS.Font
			AIMSTATUS2.Color = AIMSTATUS.Color
			AIMSTATUS2.OutlineColor = AIMSTATUS.OutlineColor
			AIMSTATUS2.Transparency = AIMSTATUS.Transparency
			AIMSTATUS2.Size = AIMSTATUS.Size
			AIMSTATUS2.Center = true
			AIMSTATUS2.Position = Vector2.new(AIMSTATUS.Position.X+AIMSTATUS.TextBounds.X/2+AIMSTATUS2.TextBounds.X/2,AIMSTATUS.Position.Y)
		else
			AIMSTATUS.Visible=false
			AIMSTATUS2.Visible=AIMSTATUS.Visible
		end
		if PATHFINDING then 
            --PATHSTATUS
		end
	end
    if XRAYB and XRAYBU then
    XRAY(XRAYM)  end
end)


--- A little bit of insight, this script is the rebirth of Skidmund, a script I never released, aspiring the same objective, but in a much more efficient way.
---
--[[ Reference
local Tab= Library.CreateLib("TITLE", "DarkTheme")

local Section = Tab:NewSection("Section Name")

Section:UpdateSection("Section New Title")

Section:NewLabel("LabelText")

label:UpdateLabel("New Text")

Section:NewButton("ButtonText", "ButtonInfo", function()
    print("Clicked")
end)

button:UpdateButton("New Text")

Section:NewToggle("ToggleText", "ToggleInfo", function(state)
    if state then
        print("Toggle On")
    else
        print("Toggle Off")
    end
end)

Section:NewSlider("SliderText", "SliderInfo", 500, 0, function(s) -- 500 (MaxValue) | 0 (MinValue)
    game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = s
end)

Section:NewTextBox("TextboxText", "TextboxInfo", function(txt)
	print(txt)
end)

Section:NewKeybind("KeybindText", "KeybindInfo", Enum.KeyCode.F, function()
	print("You just clicked the bind")
end)


Library:ToggleUI()

Section:NewDropdown("DropdownText", "DropdownInf", {"Option 1", "Option 2", "Option 3"}, function(currentOption)
    print(currentOption)
end)

]]
---

---
DeletedInstances = {}
TPRaycastConfig = RaycastParams.new()
TPRaycastConfig.FilterType = Enum.RaycastFilterType.Blacklist
TPRaycastConfig.IgnoreWater = true
Mouse.Button1Down:connect(function()
if CLICKTP and Mouse and FIRING == false then
if UserChar then
local n,s = GetBoundingBox(UserChar,true)
TPRaycastConfig.FilterDescendantsInstances={workspace.CurrentCamera,UserChar}
local raycast = workspace:Raycast(workspace.CurrentCamera.CFrame.p,Mouse.UnitRay.Direction*5000,TPRaycastConfig)
if raycast and raycast.Instance and raycast.Position then else UserChar:PivotTo(CFrame.new(Mouse.Hit.p)*UserChar:GetModelCFrame().Rotation) return end
--local offset = CLICKTPOFFSET and Vector3.new(0,s.Y/2,0) or Vector3.new(0,0,0)
if UserHum then UserHum.Sit = false end
game:GetService("RunService").Heartbeat:Wait()
UserChar:PivotTo(CFrame.new(raycast.Position+Vector3.new(0,s.Y/2,0))*UserChar:GetModelCFrame().Rotation)
if hr and raycast.Instance and raycast.Instance:IsA("BasePart") then hr.AssemblyLinearVelocity = raycast.Instance.AssemblyLinearVelocity end
end
end

if CLICKDEL and Mouse and FIRING == false then
if Mouse.Target then if Mouse.Target:FindFirstAncestorWhichIsA("Model") and Mouse.Target:FindFirstAncestorWhichIsA("Model"):FindFirstChildOfClass("Humanoid") or Mouse.Target:FindFirstAncestorWhichIsA("Camera") or table.find(DeletedInstances,Mouse.Target) then else
DeletedInstances[Mouse.Target]={Mouse.Target,Mouse.Target.Size}
Mouse.Target.Size = Vector3.new(0,0,0)
end
end
end
end)

--- Global Variables
ESP = false
flight = false
flightnograv = false
nograv = false
fspeed = 10
spdsp=16
spd=false
superman=false
CROSS=false
CROSSC=Color3.new(1,1,1)
CROSSS=15
IMMORTALITY=false
SWIM=false
XRAYB=false
HESPT = false
NTAGST = false
NTAGSV = 150
NTAGV = 15
FIRING = false
firedelay = 1/5
MAPRESTORING = false
FOVSET = false
CROSSTRAN = 100
---

spawn(function() repeat wait() until FOVSET while workspace.CurrentCamera and FOVSET==true do workspace.CurrentCamera.Changed:Wait() workspace.CurrentCamera.FieldOfView = FOV end end) --- This is the FOV magic

---
local GUI = Gaylib.CreateLib("X-PL0X", "BloodTheme")
local Visuals = GUI:NewTab("Visuals")
local ESPS = Visuals:NewSection("Render")
ESPS:NewToggle("ESP", "Toggles ESP duh", function(state)
		ESP = state
end)
ESPS:NewToggle("Crosshair", "'Nice crosshair, where'd you get it?'", function(state)
	CROSS = state
end)
ESPS:NewToggle("X-Ray", "'This nigga's superman or something..'", function(state)
XRAYB = state
if not XRAYB then XRAY(0) else XRAY(XRAYM) end
end)
ESPS:NewToggle("FOV", "'Widelens simulator'", function(state)
FOVSET = state
FOV = workspace.CurrentCamera.FieldOfView
end)
ESPS:NewSlider("FOV amount", "'Widelens simulator'", 120, 1, function(s)
FOV = s
if FOVSET==true then Camera.FieldOfView = s end
end)
local Util = GUI:NewTab("Utilities")
local SPDS = Util:NewSection("Movement")
local SPDT = SPDS:NewToggle("Walkspeed","run fast as fuck boiiiii",function(state)spd=state end)
local FLYT = SPDS:NewToggle("Flight", "you fly duh", function(state)
if not state and FIDGETSPINNER then turnflightbackon() return end --- literally fucking stupid bro
	if state then
		movedir=Vector3.new(0,0,0)
		if UserHum then UserHum.Sit = false end
		game:GetService("RunService").Heartbeat:Wait()
		flight=true
		spawn(function() ---- This is the only fucking way I can do it
			repeat wait() until UserHum
			local FallingDown = UserHum:GetStateEnabled(Enum.HumanoidStateType.FallingDown)
			local Running = UserHum:GetStateEnabled(Enum.HumanoidStateType.Running)
			local RunningNoPhysics = UserHum:GetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics)
			local Climbing = UserHum:GetStateEnabled(Enum.HumanoidStateType.Climbing)
			local StrafingNoPhysics = UserHum:GetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics)
			local Ragdoll = UserHum:GetStateEnabled(Enum.HumanoidStateType.Ragdoll)
			local GettingUp = UserHum:GetStateEnabled(Enum.HumanoidStateType.GettingUp)
			local Jumping = UserHum:GetStateEnabled(Enum.HumanoidStateType.Jumping)
			local Landed = UserHum:GetStateEnabled(Enum.HumanoidStateType.Landed)
			local Flying = UserHum:GetStateEnabled(Enum.HumanoidStateType.Flying)
			local Freefall = UserHum:GetStateEnabled(Enum.HumanoidStateType.Freefall)
			local Seated = UserHum:GetStateEnabled(Enum.HumanoidStateType.Seated)
			local PlatformStanding = UserHum:GetStateEnabled(Enum.HumanoidStateType.PlatformStanding)
			local Swimming = UserHum:GetStateEnabled(Enum.HumanoidStateType.Swimming)
			local Physics = UserHum:GetStateEnabled(Enum.HumanoidStateType.Physics)
			local None = UserHum:GetStateEnabled(Enum.HumanoidStateType.None)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.FallingDown,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Running,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Climbing,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.GettingUp,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Jumping,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Landed,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Flying,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Freefall,true)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Seated,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Swimming,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Physics,false)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.None,false)
			spawn(function() repeat wait() until flight==false
				UserHum:SetStateEnabled(Enum.HumanoidStateType.FallingDown,FallingDown)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Running,Running)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics,RunningNoPhysics)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Climbing,Climbing)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics,StrafingNoPhysics)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,Ragdoll)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.GettingUp,GettingUp)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Jumping,Jumping)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Landed,Landed)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Flying,Flying)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Freefall,Freefall)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Seated,Seated)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding,PlatformStanding)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Swimming,Swimming)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.Physics,Physics)
				UserHum:SetStateEnabled(Enum.HumanoidStateType.None,None)
			end) end)
		if SUPERMANN and superman then SUPERMANN:Play(.1,1,0) end
	else flight=false movedir=Vector3.new(0,0,0) if SUPERMANN then SUPERMANN:Stop() end
	end
	changestatus(UserHum)
end)
function turnflightbackon() FLYT:UpdateToggle("Flight",true) end --- most simple retarded solution I could find
SPDS:NewToggle("Vertical lock", "Tired of falling?", function(state)
verticallock=state
end)
local CLICKTPT = SPDS:NewToggle("Click teleport", "Check the settings for it before using", function(state)
CLICKTPTOG=state
end)
local CLICKTPT = SPDS:NewToggle("Click 'delete'", "Check the settings for it before using", function(state)
CLICKDELTOG=state
end)
SPDS:NewButton("Restore map", "Hate what you did to it?", function()
if MAPRESTORING == false then
MAPRESTORING = true
for _,Brick in pairs(DeletedInstances) do
if Brick[1] and Brick[2] then
Brick[1].Size = Brick[2]
DeletedInstances[_]=nil
else DeletedInstances[_]=nil
end
end
MAPRESTORING = false
end
end)
local AMBTS = Util:NewSection("Automation")
local AIMBOTTOG = AMBTS:NewToggle("Aimbot", "Automates the whole aiming process", function(state)
AIMBOT=state
end)
local triggerbottog = AMBTS:NewToggle("Triggerbot", "Automates the whole aiming process", function(state)
TRIGGERBOT=state
end)
local mousespooftog = AMBTS:NewToggle("Silent Aim", "spoofs aiming in on itself", function(state)
MOUSESPOOF = state
if not state then game:GetService("RunService").RenderStepped:Wait() spoofer:unspoof(Mouse) end
end)
aimbotkbmode = "None"
local AIMBOTKBMODE = AMBTS:NewDropdown("Aim key mode", "i'm a fucking genius bro", {"None", "Toggle", "Hold"}, function(currentOption)
aimbotkbmode = currentOption
end)
local AUTOWALKTOG = AMBTS:NewToggle("Auto walk", "if noob then walktonoob() end", function(state)
autowalk = status
end)

local Spoofing = GUI:NewTab("Spoofing")
---
local SPFN = Spoofing:NewSection("Network")
local BRAZILWIFI = SPFN:NewTextBox("Outbound KB/s", "Max (and default) is 64KB/s", function(am)
	OKBPS = math.clamp(math.abs(tonumber(am)),1,64) or 64
    game:GetService("NetworkClient"):SetOutgoingKBPSLimit(OKBPS)
end)
local BRAZILPING = SPFN:NewTextBox("Replication lag", "It's a multiplier. Any number.", function(am)
	RLAG = tonumber(math.abs(am)) or 0
    settings().Network.IncomingReplicationLag = RLAG
end)
---
local Misc = GUI:NewTab("Miscellaneous")
local MiscVis = Misc:NewSection("Visuals (some might not work because roblox)")
MiscVis:NewToggle("'Wireframe'", "It's supposed to work....", function(state)
    settings().Rendering.RenderCSGTrianglesDebug = state
end)
MiscVis:NewToggle("Bounding Boxes", "Draws box around EVERYTHING", function(state)
    settings().Rendering.ShowBoundingBoxes = state
end)
MiscVis:NewToggle("VRAM unlocker", "Disables vram cap", function(state)
    settings().Rendering.EagerBulkExecution = state
end)
MiscVis:NewTextBox("Change mesh cache", "Default size is 32MB", function(state)
    settings().Rendering.MeshCacheSize = tonumber(state) or 32
end)
MiscVis:NewToggle("Diagnostic mode", "Toggles diagnostic mode", function(state)
    if state then settings().Rendering.GraphicsMode = Enum.GraphicsMode.NoGraphics
    else
    settings().Rendering.GraphicsMode = Enum.GraphicsMode.Automatic end
end)
local Prot = GUI:NewTab("Protection")
local MSECT = Prot:NewSection("Character")
local MTOG = MSECT:NewToggle("Disable death","Death? Is this a bad joke?",function(state)
	IMMORTALITY=state
	spawn(function()
		repeat wait() until UserHum
		local hst = UserHum:GetStateEnabled(15)
		if state then spawn(function() repeat wait() until IMMORTALITY==false UserHum:SetStateEnabled(15,hst) end) end
	end)
	changestatus(UserHum)
end)
local FELOOPPROTTOG = MSECT:NewToggle("Anti feloop","Prevents tool equipping",function(state)
AFELOOP=state
end)
local FPDST = MSECT:NewToggle("Ignore destruction layer","Fall for 99999 seconds challenge",function(state)
	FPDSD = state
	spawn(function()
		local hst = workspace.FallenPartsDestroyHeight
		workspace.FallenPartsDestroyHeight = math.huge-math.huge
		if FPDSD then spawn(function() repeat wait() until FPDSD==false workspace.FallenPartsDestroyHeight=hst end) end
	end)
end)
local Gim = GUI:NewTab("Gimmicks")
local CharGim = Gim:NewSection("Character")
local TrollGim = Gim:NewSection("Trolling")
sounddebounce = false
local PlaySounds = TrollGim:NewButton("Fuck... I hate niggers....", "Plays every sound [FE]", function()
if sounddebounce then return else sounddebounce = true end
spawn(function() wait(1) sounddebounce=false end)
for _,S in pairs(workspace:GetDescendants()) do if S:IsA("Sound") then S:Play() end end
end)
local StopSounds = TrollGim:NewButton("NIGGERS ARE BLACK BRO!!!! SCARY.", "Stops every sound [FE]", function()
if sounddebounce then return else sounddebounce = true end
spawn(function() wait(1) sounddebounce=false end)
for _,S in pairs(workspace:GetDescendants()) do if S:IsA("Sound") then S:Stop() end end
end)
local ScrambleSounds = TrollGim:NewButton("Poop. Toluene Miller gay sex.", "Stops every sound [FE]", function()
if sounddebounce then return else sounddebounce = true end
spawn(function() wait(1) sounddebounce=false end)
for _,S in pairs(workspace:GetDescendants()) do if S:IsA("Sound") then S:Pause() S.TimePosition = math.random(0,S.TimeLength) S:Resume() end end
end)
local EARRAPE = TrollGim:NewButton("Poop. Toluene Miller gay sex.", "Stops every sound [FE]", function()
if sounddebounce then return else sounddebounce = true end
spawn(function() wait(1) sounddebounce=false end)
for _,S in pairs(workspace:GetDescendants()) do if S:IsA("Sound") then S:Pause() local oldvol = S.Volume S.Volume=10 local earrape = Instance.new("DistortionSoundEffect",S) earrape.Level = .5 earrape.Priority = 2^31 S:Resume() spawn(function() repeat wait() until S.Stopped S.Volume = oldvol earrape:Remove() end) end end
end)
local FidgetSpinner = TrollGim:NewToggle("Fidget spinner", "This is a certified hood classic.", function(state)
FIDGETSPINNER = state
if state then FLYT:UpdateToggle("Flight",true) else hr.AssemblyAngularVelocity = Vector3.new(0,0,0) end
end)
function updsoundtroll() --- too lazy to copypaste the same function twice lol
if game:GetService("SoundService").RespectFilteringEnabled==true then
PlaySounds:UpdateButton("Play sounds [Local]")
StopSounds:UpdateButton("Stop sounds [Local]")
ScrambleSounds:UpdateButton("Scramble sounds [Local]")
EARRAPE:UpdateButton("Earrape playback [Local]")
else
PlaySounds:UpdateButton("Play sounds [Global]")
StopSounds:UpdateButton("Stop sounds [Global]")
ScrambleSounds:UpdateButton("Scramble sounds [Global]")
EARRAPE:UpdateButton("Earrape playback [Global]")
end end updsoundtroll()
function swimfunc(a)
	spawn(function() ---- This is the only fucking way I can do it
		repeat wait() until UserHum
        if FallingDown and Running and RunningNoPhysics and Climbing and StrafingNoPhysics and Ragdoll and GettingUp and Jumping and Landed and Flying and Freefall and Seated and PlatformStanding and Swimming and Physics then else

		FallingDown = UserHum:GetStateEnabled(Enum.HumanoidStateType.FallingDown)
		Running = UserHum:GetStateEnabled(Enum.HumanoidStateType.Running)
		RunningNoPhysics = UserHum:GetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics)
		Climbing = UserHum:GetStateEnabled(Enum.HumanoidStateType.Climbing)
		StrafingNoPhysics = UserHum:GetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics)
		Ragdoll = UserHum:GetStateEnabled(Enum.HumanoidStateType.Ragdoll)
		GettingUp = UserHum:GetStateEnabled(Enum.HumanoidStateType.GettingUp)
		Jumping = UserHum:GetStateEnabled(Enum.HumanoidStateType.Jumping)
		Landed = UserHum:GetStateEnabled(Enum.HumanoidStateType.Landed)
		Flying = UserHum:GetStateEnabled(Enum.HumanoidStateType.Flying)
		Freefall = UserHum:GetStateEnabled(Enum.HumanoidStateType.Freefall)
		Seated = UserHum:GetStateEnabled(Enum.HumanoidStateType.Seated)
		PlatformStanding = UserHum:GetStateEnabled(Enum.HumanoidStateType.PlatformStanding)
		Swimming = UserHum:GetStateEnabled(Enum.HumanoidStateType.Swimming)
		Physics = UserHum:GetStateEnabled(Enum.HumanoidStateType.Physics)
		--local None = UserHum:GetStateEnabled(Enum.HumanoidStateType.None)
        end
        UserHum:SetStateEnabled(Enum.HumanoidStateType.FallingDown,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Running,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Climbing,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.GettingUp,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Jumping,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Landed,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Flying,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Freefall,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Seated,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding,false)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Swimming,true)
		UserHum:SetStateEnabled(Enum.HumanoidStateType.Physics,false)
		--UserHum:SetStateEnabled(Enum.HumanoidStateType.None,false)
		repeat wait() until SWIM==false or User.CharacterAdded
            if SWIM==false then
            local UserHum = User.Character:FindFirstChildOfClass("Humanoid")
            if UserHum then
			UserHum:SetStateEnabled(Enum.HumanoidStateType.FallingDown,FallingDown)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Running,Running)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics,RunningNoPhysics)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Climbing,Climbing)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics,StrafingNoPhysics)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,Ragdoll)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.GettingUp,GettingUp)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Jumping,Jumping)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Landed,Landed)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Flying,Flying)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Freefall,Freefall)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Seated,Seated)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding,PlatformStanding)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Swimming,Swimming)
			UserHum:SetStateEnabled(Enum.HumanoidStateType.Physics,Physics)
			--UserHum:SetStateEnabled(Enum.HumanoidStateType.None,None)
            FallingDown,Running,RunningNoPhysics,Climbing,StrafingNoPhysics,Ragdoll,GettingUp,Jumping,Landed,Flying,Freefall,Seated,PlatformStanding,Swimming,Physics = nil
            end
            elseif SWIM==true then swimfunc() end
	end)
end --- another retard solution
game:GetService("SoundService").Changed:Connect(function(s) if s=="RespectFilteringEnabled" then updsoundtroll() end end) --- in case something changes FE sounds mid-game.
local swmT = CharGim:NewToggle("Air swim","Do crabs think fish fly?",function(state)
	SWIM = state
    if state then swimfunc() end
	changestatus(UserHum)
end)
local NOGRAV = CharGim:NewToggle("No gravity", "poland cannot into space", function(state) 
nograv = state
end)

--[[
Will be added later
local Spoofing = GUI:NewTab("Spoofing")
local Misc = GUI:NewTab("Miscellaneous")
local Prot = GUI:NewTab("Protection") 
local Util = GUI:NewTab("Utilities")
local Gim = GUI:NewTab("Gimmicks")
]]
---
local Statsz = GUI:NewTab("Stats")
local ClientStats = Statsz:NewSection("Client")
local ServerStats = Statsz:NewSection("Server")

local FPSL = ClientStats:NewLabel("FPS")
local PINGL = ClientStats:NewLabel("Ping")
local PhysL = ClientStats:NewLabel("Physics TPS")
local PhysLR = ClientStats:NewLabel("REAL")

local TPSL = ServerStats:NewLabel("TPS")
local PTPSL = ServerStats:NewLabel("Physics TPS")
---
local Settings = GUI:NewTab("Settings")
local ESPSET = Settings:NewSection("ESP")
local CROSSSET = Settings:NewSection("Crosshair")
local XRAYSET = Settings:NewSection("X-Ray")
local TEAMCOLOREDBOXt = ESPSET:NewToggle("Team coloured boxes", "have sex with children", function(state) 
	COLOREDBOXES=state
end)
TEAMCOLOREDBOXt:UpdateToggle("Team coloured boxes",true)
local mn = ESPSET:NewToggle("Directional Arrows", "y u no like dem??", function(state) 
	ARW=state
end)
local mn2 = ESPSET:NewToggle("Healthbar", "buh ðŸ’€", function(state) 
	HLT=state
end)
local HESP = ESPSET:NewToggle("Show heads", "gg ez onetap", function(state) 
HESPT = state
end)
local TRACERS = ESPSET:NewToggle("Tracers", "omg guys i found him!!", function(state) 
TRACERST = state
end)
local NTAG = ESPSET:NewToggle("Nametags", "u n00b ncca?", function(state) 
NTAGST = state
end)
local NTAGS = ESPSET:NewSlider("Nametag offset", "(Y%)", 400, -400, function(s)
NTAGSV = s
end)
local NTAGS = ESPSET:NewTextBox("Nametag size", "Any non-imaginary number", function(s)
NTAGV = s
end)
ESPSET:NewDropdown("Font", "I like your style.", {"UI", "System", "Plex", "Monospace"}, function(currentOption)
FONT = Drawing.Fonts[currentOption]
end)
mn2:UpdateToggle("Healthbar",true)

local CROSSCS = CROSSSET:NewColorPicker("Crosshair color", "Choose whatever color", Color3.fromRGB(255,255,255), function(color)
	CROSSC = color
end)
local CROSSTRANSEL = CROSSSET:NewSlider("Crosshair (%)", "How opaque?", 100, 0, function(s)
	CROSSTRAN = s
end)
local CROSSSZ = CROSSSET:NewTextBox("Crosshair size","Any non-imaginary number", function(am)
	CROSSS = tonumber(am) or 15
end)
local XRAYSETT = XRAYSET:NewSlider("X-Ray (%)", "100% = map is invisible", 100, 0, function(s)
XRAYM = s/100
end)
local AUTOUPDXRAY = XRAYSET:NewToggle("X-Ray autoupdate", "VERY resource intensive", function(state) 
XRAYBU=state
end)
AUTOUPDXRAY:UpdateToggle("X-Ray autoupdate",true)
local UPDXRAY = XRAYSET:NewButton("X-Ray manual update", "Manually update X-RAY", function() 
if XRAYB then
XRAY(XRAYM)
end
end)

local SPDSET = Settings:NewSection("Movement")
local FLYSP = SPDSET:NewTextBox("Flight speed","Any non-imaginary number", function(am)
	fspeed = tonumber(am) or 10
end)
local SUPRMN = SPDSET:NewToggle("Superman mockup", "wtf are you superman ncca?", function(state) superman=state 
	if state and SUPERMANN then
		spawn(function()
			repeat wait() until flight==true
			if superman==false then else
				if SUPERMANN then
					SUPERMANN.Priority = Enum.AnimationPriority.Action
					SUPERMANN.TimePosition = 1
					SUPERMANN.Looped = true
					SUPERMANN:Play(.1,1,0) end
			end
		end)
	elseif not state or flight==false then
		if SUPERMANN then
			SUPERMANN:Stop() 
		end
	end
end)
local FLIGHTNOGRAV = SPDSET:NewToggle("Anti flight drift", "prevents vertical drift", function(state) 
flightnograv = state
end)
FLIGHTNOGRAV:UpdateToggle("Anti flight drift",true)
local SPDP = SPDSET:NewTextBox("Walkspeed","Any non-imaginary number", function(am)
	spdsp = tonumber(am) or 16
end)
local SPDDRFT = SPDSET:NewToggle("Anti slip","Any non-imaginary number", function(am)
SPEEDDRIFT = am
end)
SPDDRFT:UpdateToggle("Anti slip",true)
local BINDSET = Settings:NewSection("Keybinds")
local CLICKTPKB = BINDSET:NewKeybind("Click teleport bind", "This is the keybind for it", Enum.KeyCode.LeftControl, function(bind)
if CLICKTPTOG and FIRING == false then
if CLICKTP then
CLICKTP = false
else CLICKTP = true spawn(function() while game:GetService("UserInputService"):IsKeyDown(bind) do game:GetService("UserInputService").InputEnded:Wait() end CLICKTP = false end)
end
end
end)
local CLICKDELKB = BINDSET:NewKeybind("Click delete bind", "This is the keybind for it", Enum.KeyCode.RightAlt, function(bind)
if CLICKDELTOG and FIRING == false and MAPRESTORING==false then
if CLICKDEL then
CLICKDEL = false
else CLICKDEL = true spawn(function() while game:GetService("UserInputService"):IsKeyDown(bind) do game:GetService("UserInputService").InputEnded:Wait() end CLICKDEL = false end)
end
end
end)
local FLIGHTKB = BINDSET:NewKeybind("Click delete bind", "This is the keybind for it", Enum.KeyCode.KeypadPlus, function(bind)
if flight then
FLYT:UpdateToggle("Flight",false) else FLYT:UpdateToggle("Flight",true) end
end)
local AIMBOTKB = BINDSET:NewKeybind("Aimbot bind", "This is the keybind for it", Enum.KeyCode.V, function(bind)
if AIMBOT then
if aimbotkbmode=="Toggle" then
AIMBOTTOG:UpdateToggle("Aimbot",false)AIMBOT=false end
else 
if aimbotkbmode=="Toggle" then
AIMBOTTOG:UpdateToggle("Aimbot",true)AIMBOT=true
elseif aimbotkbmode=="Hold" then AIMBOTTOG:UpdateToggle("Aimbot",true) spawn(function() while game:GetService("UserInputService"):IsKeyDown(bind) or AIMBOT==false do game:GetService("UserInputService").InputEnded:Wait() end AIMBOTTOG:UpdateToggle("Aimbot",false) end) end
end
end)


local TARGETSETBANNER = Settings:NewSection("Targeting")
local TGTLIST = TARGETSETBANNER:NewTextBox("Target", "FETCH ME THEIR SOULS!!!!", function(txt)
TGT = MatchName(txt)
end)
local TPTOBTN = TARGETSETBANNER:NewButton("Teleport", "Instant transmission?", function(txt)
if TGT and TGT[1] and TGT[1].Character and RANDOMTGT~=true then 
		if UserHum then UserHum.Sit = false end
		game:GetService("RunService").Heartbeat:Wait()
UserChar:PivotTo(TGT[1].Character:GetModelCFrame()) 
else
		if UserHum then UserHum.Sit = false end
		game:GetService("RunService").Heartbeat:Wait()
UserChar:PivotTo(randomplayer().Character:GetModelCFrame())
end
end)
local AIMBOTSETBANNER = Settings:NewSection("Aimbot")
local TEAMCHECK = AIMBOTSETBANNER:NewToggle("Team check", "friendly fire is banned!!", function(state)
teamcheck = state
end)
local WALLCHECK = AIMBOTSETBANNER:NewToggle("Wall check", "friendly fire is banned!!", function(state)
wallcheck = state
end)
local AIMSPEED = AIMBOTSETBANNER:NewTextBox("Aim speed", "gay fart sex penis", function(s)
aimspeed = s
end)
local HEADAIM = AIMBOTSETBANNER:NewToggle("Headshot", "onetap 2.0 (real)", function(state)
headaim = state
end)
local SHOOTRAD = AIMBOTSETBANNER:NewTextBox("Trigger radius", "BOOM HEADSHOT!", function(am)
shootrad = am
end)
local SHOOTSPEED = AIMBOTSETBANNER:NewTextBox("Shots per second", "BRRRT", function(am)
local number = 1000
if tonumber(am) then number = am end
firedelay = 1/number
end)
shootrad = 5
aimspeed = 13.2
local RANDOMTARGETTOGGLE = TARGETSETBANNER:NewToggle("Random target", "Chooses any target at random", function(state) 
RANDOMTGT=state
end)
---
local Credits = GUI:NewTab("Credits")
local Thx = Credits:NewSection("Thanks to:")
local Thxwho = Thx:NewLabel("Github - home of this shit")
local Thxwho2 = Thx:NewLabel("xHeptc - fuck you nigga why can't I fuck this UI???")
local Thxwho3 = Thx:NewLabel("rqccc - taught me how to get server ping")
local DC = GUI:NewTab("Discord")
local mm=DC:NewSection("Discord Server")
local m=mm:NewButton("Copy to clipboard", "copies discord invite to clipboard", function()
if discorddebounce then else
	setclipboard('https://discord.gg/eCtE2ukNVV')
	m:UpdateButton("Copied!")
    discorddebounce=true
	wait(1)
    discorddebounce=nil
	m:UpdateButton("Copy to clipboard")
end
end)
---
--[[  So yeah this is ESP template and stuff

[Player] = 
{
    Plr,
    Box,
    Healthbar = {},
    Arrow = {},
}

]]
--- Custom Functions and shit
PLAYERLIST = {}
lowvalue = 2^31-1
highvalue = -lowvalue
--StatsService = game:GetService("Stats") --- redundant af
StatsService = stats()
UserInputService = game:GetService("UserInputService")
DELTA = 0
Ping = StatsService:WaitForChild("Network"):WaitForChild("ServerStatsItem"):WaitForChild("Data Ping")
ContextActionService = game:GetService("ContextActionService")
movedir=Vector3.new(0,0,0)
f,b,l,r = false,false,false,false
function refreshplayers()
	game:GetService("RunService").RenderStepped:Wait()

	for _,L in pairs(PLAYERLIST) do L.Tracer:Remove() L.Head:Remove() L.Nametag:Remove() L.Healthbar[1]:Remove() L.Healthbar[2]:Remove() L.Box:Remove() L.Arrow[1]:Remove() L.Arrow[2]:Remove() L.Arrow[3]:Remove() L.Arrow[4]:Remove() L.Arrow[5]:Remove() L.Arrow[6]:Remove() L.Arrow[7]:Remove() L.Arrow[8]:Remove() L.Arrow[9]:Remove() L.Arrow[10]:Remove() PLAYERLIST[_]=nil end
	local PlayerList = game:GetService("Players"):GetPlayers()
	for _,L in pairs(PlayerList) do 
		if L and L~=User then
			PLAYERLIST[L]={L,Tracer=Drawing.new("Line"),Head=Drawing.new("Circle"),Nametag=Drawing.new("Text"),Box=Drawing.new("Quad"),Healthbar={Drawing.new("Quad"),Drawing.new("Quad")},Arrow={Drawing.new("Quad"),Drawing.new("Triangle"),Drawing.new("Quad"),Drawing.new("Triangle"),Drawing.new("Quad"),Drawing.new("Quad"),Drawing.new("Quad"),Drawing.new("Quad"),Drawing.new("Quad"),Drawing.new("Quad")}} 
		end
	end
end
function randomplayer()
local temptable = game:GetService("Players"):GetPlayers()
table.remove(temptable,table.find(temptable,User))
return temptable[math.random(1,#temptable)]
end
function MatchName(Player)  ----copypasted from my other mf project, just modified it right now, it should autocomplete.... faster.
local tab = {}
		for _,player in pairs(game:GetService("Players"):GetPlayers()) do
					if tostring(player.DisplayName):lower():find(tostring(Player):lower())==1 or tostring(player.Name):lower():find(tostring(Player):lower())==1 then
						table.insert(tab,player)
					end
				end
return tab
end
WallRaycastConfig = RaycastParams.new()
WallRaycastConfig.FilterType = Enum.RaycastFilterType.Blacklist
WallRaycastConfig.IgnoreWater = true
function GetClosestPlayer(d,t,w,h,a)
WallRaycastConfig.FilterDescendantsInstances={Camera,UserChar}
local d = d or 25000
local player = nil
for _,players in pairs(game:GetService("Players"):GetPlayers()) do
if players~=User and players.Character and UserChar then
local dist = (UserChar:GetModelCFrame().p-players.Character:GetModelCFrame().p).Magnitude
if dist<d then else continue end
if t then if players.TeamColor ~= User.TeamColor then else continue end end
if UserChar:FindFirstChildOfClass("Humanoid") then if UserChar:FindFirstChildOfClass("Humanoid").Health==0 or UserChar:FindFirstChildOfClass("Humanoid"):GetState() == Enum.HumanoidStateType.Dead then continue end end
if a==true then if players.Character:FindFirstChildOfClass("Humanoid") and (players.Character:FindFirstChildOfClass("Humanoid").Health==0 or players.Character:FindFirstChildOfClass("Humanoid"):GetState() == Enum.HumanoidStateType.Dead) then continue else end end
if w then
local ray2 = workspace:Raycast(Camera.CFrame.p,(players.Character:GetModelCFrame().p-Camera.CFrame.p).Unit*d,WallRaycastConfig)
local ray1 = ray2
if players:FindFirstChild("Head") then ray1 = workspace:Raycast(Camera.CFrame.p,(UserChar:FindFirstChild("Head").CFrame.p-Camera.CFrame.p).Unit*d,WallRaycastConfig) end
if h then
if ray1==nil or ray1.Instance==nil or game:GetService("Players"):GetPlayerFromCharacter(ray1.Instance:FindFirstAncestorOfClass("Model"))==players then else continue end 
else
if ray2==nil or ray2.Instance==nil or game:GetService("Players"):GetPlayerFromCharacter(ray2.Instance:FindFirstAncestorOfClass("Model"))==players then else continue end 
end
end
d = dist
player = players
end
end
return player
end

refreshplayers() 
game:GetService("Players").PlayerAdded:connect(function() refreshplayers()  end)
game:GetService("Players").PlayerRemoving:connect(function() refreshplayers()  end)
local function MOVEMENT(actionname, inputstate, inputobject) --- I FUCKING HATE CONTEXTACTIONSERVICE!!!!!!!!!!!!!!!!!!!!!!!!!
	if flight then
		if f==false and actionname == "f" and inputstate == Enum.UserInputState.Begin then f=true movedir = Vector3.new(movedir.X,movedir.Y,movedir.Z-1) end
		if b==false and actionname == "b" and inputstate == Enum.UserInputState.Begin then b=true movedir = Vector3.new(movedir.X,movedir.Y,movedir.Z+1) end
		if l==false and actionname == "l" and inputstate == Enum.UserInputState.Begin then l=true movedir = Vector3.new(movedir.X-1,movedir.Y,movedir.Z) end
		if r==false and actionname == "r" and inputstate == Enum.UserInputState.Begin then r=true movedir = Vector3.new(movedir.X+1,movedir.Y,movedir.Z) end

		if f==true and actionname == "f" and inputstate == Enum.UserInputState.End then f=false movedir = Vector3.new(movedir.X,movedir.Y,movedir.Z+1) end
		if b==true and actionname == "b" and inputstate == Enum.UserInputState.End then b=false movedir = Vector3.new(movedir.X,movedir.Y,movedir.Z-1) end
		if l==true and actionname == "l" and inputstate == Enum.UserInputState.End then l=false movedir = Vector3.new(movedir.X+1,movedir.Y,movedir.Z) end
		if r==true and actionname == "r" and inputstate == Enum.UserInputState.End then r=false movedir = Vector3.new(movedir.X-1,movedir.Y,movedir.Z) end
	end end
ContextActionService:BindAction("f", MOVEMENT, false, Enum.PlayerActions.CharacterForward)
ContextActionService:BindAction("b", MOVEMENT, false, Enum.PlayerActions.CharacterBackward)
ContextActionService:BindAction("l", MOVEMENT, false, Enum.PlayerActions.CharacterLeft)
ContextActionService:BindAction("r", MOVEMENT, false, Enum.PlayerActions.CharacterRight)
UserInputService.InputChanged:Connect(function(input, gameProcessed) if gameProcessed then movedir = Vector3.new(0,0,0) f,b,l,r = false,false,false,false  end end)---UI BUGFIX
--- Whatever else section
function flighregulate() if hr.AssemblyLinearVelocity.Magnitude>fspeed/100 then hr.AssemblyLinearVelocity = Vector3.new(0,0,0)end end
game:GetService("RunService").Stepped:connect(function(a,d) ---inefficient but I think it'd be more if I spread it accross renderS and S, plus ws won't work if .RS is used
	physTPS=d or 0
	if hr and flight then
		local movedir2 = movedir
		if movedir.Magnitude>0 then
			movedir2 = movedir.Unit 
		end
		local cf = (workspace.CurrentCamera.CFrame.Rotation+hr.CFrame.p):ToWorldSpace(CFrame.new(movedir2*(fspeed/100)))
		Phys:MoveTo(hr,cf,750)
		if superman and movedir2.Magnitude>0 then --hr.CFrame = hr.CFrame:lerp(CFrame.new(hr.CFrame.p,cf.p),d*50) ---eh not for my taste, choppy it is!
			hr.CFrame = CFrame.new(hr.CFrame.p,cf.p)
		end
	elseif hr and flight==false then Phys:PurgePhysics(hr) else FLYT:UpdateToggle("Flight",false)
	end
	if hr and FIDGETSPINNER then flighregulate() spawn(function() game:GetService("RunService").Heartbeat:Wait() flighregulate() end)changestatus(UserHum) hr.CFrame = CFrame.new(hr.CFrame.p) hr.AssemblyAngularVelocity = Vector3.new(0,2^16,0) end--*CFrame.Angles(0,y,0) end
	if hr and spd==true and flight==false and UserHum then
        if UserHum.MoveDirection.Magnitude>0 then
		local ws = UserHum.MoveDirection.Unit*spdsp
		hr.AssemblyLinearVelocity=Vector3.new(ws.X,hr.AssemblyLinearVelocity.Y,ws.Z) 
        elseif SPEEDDRIFT then
		local ws = UserHum.MoveDirection.Unit*spdsp
        if UserHum.MoveDirection.Magnitude>0 then
		hr.AssemblyLinearVelocity=Vector3.new(ws.X,hr.AssemblyLinearVelocity.Y,ws.Z) else
        hr.AssemblyLinearVelocity=Vector3.new(0,hr.AssemblyLinearVelocity.Y,0)
        end
        end
		--elseif hr==nil or UserHum==nil then SPDT:UpdateToggle("Enable",false) ---not really needed

	
    end
	if (SWIM or nograv or (flightnograv and flight) or FIDGETSPINNER) and hr and UserHum then --
		hr:ApplyImpulse(Vector3.new(0,hr.AssemblyMass*workspace.Gravity*d,0)) --- as precise as I can go, lots of trial and error, then it suddendly came up to me when I accidentally pressed F12.
	end 
end)
windowactive = false
--- Rendering section
local fakemouseparams = RaycastParams.new()
fakemouseparams.IgnoreWater=false
game:GetService("RunService").RenderStepped:connect(function(D)
	local windowactive = isrbxactive()~=nil and isrbxactive() or iswindowactive()~=nil and iswindowactive
	DELTA = D
	AIMSTATUS.Text = "Aimbot: Polling"
    if AIMBOT and (UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter and windowactive and User.GameplayPaused==false and game:GetService("GuiService").MenuIsOpen==false) or (MOUSESPOOF and User.GameplayPaused==false and game:GetService("GuiService").MenuIsOpen==false) then 
    local target = GetClosestPlayer(25000,teamcheck,wallcheck,headaim,true)
	-- Adding the following later when I get home
		if target and target.Character then
        --if target.Character:FindFirstChildOfClass("Humanoid") then if target.Character:FindFirstChildOfClass("Humanoid").Health==0 or target.Character:FindFirstChildOfClass("Humanoid"):GetState() == Enum.HumanoidStateType.Dead then else
        local targetpos = nil
        if headaim and target.Character:FindFirstChild("Head") then
        targetpos = target.Character:FindFirstChild("Head").CFrame.p
        if MOUSESPOOF then spoofer:spoof(game:GetService("Players").LocalPlayer:GetMouse(),"Target",target.Character:FindFirstChild("Head")) end
		else targetpos = target.Character:GetModelCFrame().p 
        if MOUSESPOOF then spoofer:spoof(game:GetService("Players").LocalPlayer:GetMouse(),"Target",target.Character:FindFirstChild("HumanoidRootPart")) end
		end
		if MOUSESPOOF then spoofer:spoof(game:GetService("Players").LocalPlayer:GetMouse(),"Hit",CFrame.new(targetpos)) end
		local FinalMouse, nigger = Camera:WorldToViewportPoint(targetpos)
		if FinalMouse.Z<0 then
		FinalMouse = math2:InverseWorldToViewportPoint(targetpos)
		end
		fakemouseparams.FilterDescendantsInstances = {Mouse.TargetFilter}
		if MOUSESPOOF then spoofer:spoof(game:GetService("Players").LocalPlayer:GetMouse(),"UnitRay",workspace:Raycast(workspace.CurrentCamera.CFrame.p,(targetpos-workspace.CurrentCamera.CFrame.p).Unit,fakemouseparams)) end
		local Move = (Vector2.new(FinalMouse.X-Mouse.X,FinalMouse.Y-Mouse.Y-inset)*D/UserSettings():GetService("UserGameSettings").MouseSensitivity)/UserInputService.MouseDeltaSensitivity
		Move = Move*aimspeed
        if target.Character:FindFirstChildOfClass("Humanoid") and (target.Character:FindFirstChildOfClass("Humanoid").Health==0 or target.Character:FindFirstChildOfClass("Humanoid"):GetState() == Enum.HumanoidStateType.Dead) then else if MOUSESPOOF then else mousemoverel(Move.X,Move.Y) end AIMSTATUS.Text = "Aimbot: Aiming" if TRIGGERBOT then if math.abs(((FinalMouse.X-Mouse.X+FinalMouse.Y-Mouse.Y-inset)/2)/FinalMouse.Z) <=math.abs((Resolution.Y*(shootrad/Resolution.Y))/FinalMouse.Z) or MOUSESPOOF then spawn(function() if FIRING==false then mouse1press() AIMSTATUS2.Text = " [Shooting at "..((1/firedelay)*60).."rpm]" FIRING = true wait(firedelay) mouse1release() AIMSTATUS2.Text = "" FIRING = false  end end) end end end     
    end
	
    end
	for _,N in pairs(PLAYERLIST) do
		local Plr = _
		local Box = N.Box
		local Arrow = N.Arrow
		local Healthbar = N.Healthbar
		local Char = Plr.Character
        local HeadE = N.Head
        local NameTag = N.Nametag
        local Tracer = N.Tracer
        local Head = nil
		if ESP and Char and Box and Arrow[10] and Healthbar[2] and NameTag and HeadE and (Char:GetModelCFrame().p-Camera.CFrame.p).Magnitude<=25000 and workspace.CurrentCamera.CameraSubject ~= Char and workspace.CurrentCamera.CameraSubject ~= Char:FindFirstChildOfClass("Humanoid") then --- hard limit lol
            local Head = Char:FindFirstChild("Head")
			local Hum = Char:FindFirstChildOfClass("Humanoid")
			local Pos,Size = GetBoundingBox(Char,false,Char:GetModelCFrame())--Char:GetExtentsSize() --- the new method kills ur fps but is MUCH CLEANER. --- Removed some unnecessary vars and performance hit compared to older methods is now MINIMAL. HOORAY!!!!
            local teamcolor = COLOREDBOXES and Plr.TeamColor.Color:Lerp(Color3.new(1,1,1),.5) or Color3.new(1,1,1)


			local UR,V1 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X,Size.Y,0)/2))
			local UL,V2 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X,Size.Y,0)/2))
			local DL,V3 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X,-Size.Y,0)/2))
			local DR,V4 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X,-Size.Y,0)/2))

			Box.PointA = Vector2.new(UR.X,UR.Y)
			Box.PointB = Vector2.new(UL.X,UL.Y)
			Box.PointC = Vector2.new(DL.X,DL.Y)
			Box.PointD = Vector2.new(DR.X,DR.Y)

			--- these above are for the directional arrow



			local BUR,V19 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/1.65,Size.Y/2,0)))
			local BUL,V20 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/2,Size.Y/2,0)))
			local BDL,V21 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/2,-Size.Y/2,0)))
			local BDR,V22 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/1.65,-Size.Y/2,0)))

			local H1,H2 = 0,0

			if Hum then
				local healthperone = (Hum.Health/Hum.MaxHealth)
				--if Hum.Health==0 or Hum:GetState() == Enum.HumanoidStateType.Dead then healthperone=0 end
				local barh = -Size.Y/2+(Size.Y)*healthperone
				H1 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/1.65,barh,0)))
				H2 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/2,barh,0)))
				Healthbar[2].Color = Color3.fromHSV(healthperone*.3,0.8,1)
			else
				H1 = BDL
				H2 = BDR
			end

			Healthbar[1].PointA = Vector2.new(BUR.X,BUR.Y)
			Healthbar[1].PointB = Vector2.new(BUL.X,BUL.Y)
			Healthbar[1].PointC = Vector2.new(BDL.X,BDL.Y)
			Healthbar[1].PointD = Vector2.new(BDR.X,BDR.Y)

			Healthbar[2].PointA = Vector2.new(H1.X,H1.Y)
			Healthbar[2].PointB = Vector2.new(H2.X,H2.Y)
			Healthbar[2].PointC = Vector2.new(BDL.X,BDL.Y)
			Healthbar[2].PointD = Vector2.new(BDR.X,BDR.Y)

			--- healthbar logic above


			Box.Filled = false

			Box.Thickness = ((0.068*Resolution.Y)/(Camera.CFrame.p-(Pos.p+Vector3.new(0,Size.Y,0))).Magnitude)/(Camera.FieldOfView/70)
			Box.Color = teamcolor
			Box.ZIndex = lowvalue+2



			Healthbar[1].Filled = true
			Healthbar[1].ZIndex = Box.ZIndex+1
			Healthbar[1].Color = Color3.new(0,0,0)
			Healthbar[1].Thickness = 0--Box.Thickness

			Healthbar[2].Filled = true
			Healthbar[2].ZIndex = Healthbar[1].ZIndex+1
			Healthbar[2].Thickness = 0
            ------------
            local UR,UL,DL,DR,L,R,U,UR2,UL2,DL2,DR2,L2,U2,R2,V5,V6,V7,V8,V9,V10,V11,V12,V13,V14,V15,V16,V17,V18 = nil --- these are literally every fucking variable for the fucking arrows. Really resource intensive.
            if ARW then


            UR,V5 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/8,Size.Y,0)))
			UL,V6 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/8,Size.Y,0)))
			DL,V7 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/8,Size.Y,Size.X/2)))
			DR,V8 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/8,Size.Y,Size.X/2)))

			Arrow[1].PointA = Vector2.new(UR.X,UR.Y)
			Arrow[1].PointB = Vector2.new(UL.X,UL.Y)
			Arrow[1].PointC = Vector2.new(DL.X,DL.Y)
			Arrow[1].PointD = Vector2.new(DR.X,DR.Y)

			L,V9 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/4,Size.Y,0)))
			R,V10 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/4,Size.Y,0)))
			U,V11 = Camera:WorldToViewportPoint(Pos*(Vector3.new(0,Size.Y,-Size.X/2)))

			Arrow[2].PointA = Vector2.new(U.X,U.Y)
			Arrow[2].PointB = Vector2.new(L.X,L.Y)
			Arrow[2].PointC = Vector2.new(R.X,R.Y)

			UR2,V12 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/8,Size.Y+Size.X/5,0)))
			UL2,V13 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/8,Size.Y+Size.X/5,0)))
			DL2,V14 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/8,Size.Y+Size.X/5,Size.X/2)))
			DR2,V15 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/8,Size.Y+Size.X/5,Size.X/2)))

			Arrow[3].PointA = Vector2.new(UR2.X,UR2.Y)
			Arrow[3].PointB = Vector2.new(UL2.X,UL2.Y)
			Arrow[3].PointC = Vector2.new(DL2.X,DL2.Y)
			Arrow[3].PointD = Vector2.new(DR2.X,DR2.Y)

			L2,V16 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/4,Size.Y+Size.X/5,0)))
			R2,V17 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/4,Size.Y+Size.X/5,0)))
			U2,V18 = Camera:WorldToViewportPoint(Pos*(Vector3.new(0,Size.Y+Size.X/5,-Size.X/2)))

			Arrow[4].PointA = Vector2.new(U2.X,U2.Y)
			Arrow[4].PointB = Vector2.new(L2.X,L2.Y)
			Arrow[4].PointC = Vector2.new(R2.X,R2.Y)


            Arrow[1].Filled = true
			Arrow[2].Filled = Arrow[1].Filled
			Arrow[3].Filled = Arrow[1].Filled
			Arrow[4].Filled = Arrow[1].Filled
			Arrow[5].Filled = Arrow[1].Filled
			Arrow[6].Filled = Arrow[1].Filled
			Arrow[7].Filled = Arrow[1].Filled
			Arrow[8].Filled = Arrow[1].Filled
			Arrow[9].Filled = Arrow[1].Filled
			Arrow[10].Filled = Arrow[1].Filled

			Arrow[1].Transparency = 0.25
			Arrow[2].Transparency = Arrow[1].Transparency
			Arrow[3].Transparency = Arrow[1].Transparency
			Arrow[4].Transparency = Arrow[1].Transparency
			Arrow[5].Transparency = Arrow[1].Transparency
			Arrow[6].Transparency = Arrow[1].Transparency
			Arrow[7].Transparency = Arrow[1].Transparency
			Arrow[8].Transparency = Arrow[1].Transparency
			Arrow[9].Transparency = Arrow[1].Transparency
			Arrow[10].Transparency = Arrow[1].Transparency

			Arrow[1].Thickness = 0 --(0.06*Resolution.Y)/(Camera.CFrame.p-(Pos.p+Vector3.new(0,Size.Y,0))).Magnitude
			Arrow[1].Color = teamcolor
			Arrow[1].ZIndex = Box.ZIndex+3

			Arrow[2].Thickness = Arrow[1].Thickness*2
			Arrow[2].Color = Arrow[1].Color
			Arrow[2].ZIndex = Arrow[1].ZIndex

			Arrow[3].Thickness = Arrow[1].Thickness
			Arrow[3].Color = Arrow[1].Color
			Arrow[3].ZIndex = Arrow[1].ZIndex

			Arrow[4].Thickness = Arrow[1].Thickness*2
			Arrow[4].Color = Arrow[1].Color
			Arrow[4].ZIndex = Arrow[1].ZIndex

			Arrow[5].Thickness = Arrow[1].Thickness
			Arrow[5].Color = Arrow[1].Color
			Arrow[5].ZIndex = Arrow[1].ZIndex
			Arrow[5].PointA = Vector2.new(U2.X,U2.Y)
			Arrow[5].PointB = Vector2.new(R2.X,R2.Y)
			Arrow[5].PointC = Vector2.new(R.X,R.Y)
			Arrow[5].PointD = Vector2.new(U.X,U.Y)

			Arrow[6].Thickness = Arrow[1].Thickness
			Arrow[6].Color = Arrow[1].Color
			Arrow[6].ZIndex = Arrow[1].ZIndex
			Arrow[6].PointA = Vector2.new(U2.X,U2.Y)
			Arrow[6].PointB = Vector2.new(L2.X,L2.Y)
			Arrow[6].PointC = Vector2.new(L.X,L.Y)
			Arrow[6].PointD = Vector2.new(U.X,U.Y)

			Arrow[7].Thickness = Arrow[1].Thickness
			Arrow[7].Color = Arrow[1].Color
			Arrow[7].ZIndex = Arrow[1].ZIndex
			Arrow[7].PointA = Vector2.new(R2.X,R2.Y)
			Arrow[7].PointB = Vector2.new(L2.X,L2.Y)
			Arrow[7].PointC = Vector2.new(L.X,L.Y)
			Arrow[7].PointD = Vector2.new(R.X,R.Y)

			Arrow[8].Thickness = Arrow[1].Thickness
			Arrow[8].Color = Arrow[1].Color
			Arrow[8].ZIndex = Arrow[1].ZIndex
			Arrow[8].PointA = Vector2.new(UR2.X,UR2.Y)
			Arrow[8].PointB = Vector2.new(DR2.X,DR2.Y)
			Arrow[8].PointC = Vector2.new(DR.X,DR.Y)
			Arrow[8].PointD = Vector2.new(UR.X,UR.Y)

			Arrow[9].Thickness = Arrow[1].Thickness
			Arrow[9].Color = Arrow[1].Color
			Arrow[9].ZIndex = Arrow[1].ZIndex
			Arrow[9].PointA = Vector2.new(UL2.X,UL2.Y)
			Arrow[9].PointB = Vector2.new(DL2.X,DL2.Y)
			Arrow[9].PointC = Vector2.new(DL.X,DL.Y)
			Arrow[9].PointD = Vector2.new(UL.X,UL.Y)

			Arrow[10].Thickness = Arrow[1].Thickness
			Arrow[10].Color = Arrow[1].Color
			Arrow[10].ZIndex = Arrow[1].ZIndex
			Arrow[10].PointA = Vector2.new(DR2.X,DR2.Y)
			Arrow[10].PointB = Vector2.new(DL2.X,DL2.Y)
			Arrow[10].PointC = Vector2.new(DL.X,DL.Y)
			Arrow[10].PointD = Vector2.new(DR.X,DR.Y)
            end
            local HPV,HPV2 = nil
            HeadE.Visible = false
            if Head and Head:IsA("BasePart") then
            local avghead = (Head.Size.X+Head.Size.Y+Head.Size.Z)/3
            HPV,HPV2 = Camera:WorldToViewportPoint(Head.CFrame.p)
            HeadE.Position = Vector2.new(HPV.X,HPV.Y)
            HeadE.Radius = ((Resolution.Y*0.4*avghead)/HPV.Z)/(Camera.FieldOfView/70)
            HeadE.Thickness = ((Resolution.Y*0.2)/HPV.Z)/(Camera.FieldOfView/70)
            HeadE.Color = teamcolor
            HeadE.Transparency = math.clamp((Head.CFrame.p-Camera.CFrame.p).Magnitude-1,0,1)
            HeadE.ZIndex = lowvalue+1
            end
            local NT,NT2 = Camera:WorldToViewportPoint(Pos*Vector3.new(0,(Size.Y*NTAGSV/100),0)) --workspace.CurrentCamera.CFrame.p-Char:GetModelCFrame().p).Magnitude
            NameTag.Size = (Resolution.Y*(NTAGV/500))/(Camera.FieldOfView/70)
            NameTag.Position = Vector2.new(NT.X,NT.Y-NameTag.TextBounds.Y/2)
            NameTag.Text = Plr.DisplayName.."/"..Plr.Name
            NameTag.Center = true
            NameTag.Color = Box.Color
            NameTag.Font = FONT
            local TT = Camera:WorldToViewportPoint(Pos*Vector3.new(0,-Size.Y/2,0))
            Tracer.Thickness = (Resolution.Y*0.0016)
            Tracer.Color = Box.Color
            Tracer.Transparency = math.clamp(1-(Pos.p-Camera.CFrame.p).Magnitude/423,.32,1)
            Tracer.From = Vector2.new(Resolution.X/2,Resolution.Y*0.95)
            Tracer.ZIndex = Box.ZIndex+4
        
            --local PlrCameraOffset = Camera.CFrame:PointToObjectSpace(Pos.p) -- could be useful later for aimbot
            if TT.Z<0 then
            --[[local PlrCameraOffset = Camera.CFrame:PointToObjectSpace(Pos*Vector3.new(0,-Size.Y/2,0))
            local AT = math.atan2(PlrCameraOffset.Y, PlrCameraOffset.X) + math.pi;
            local inverse = CFrame.Angles(0, 0, AT):vectorToWorldSpace((CFrame.Angles(0, math.rad(89.9), 0):vectorToWorldSpace(Vector3.new(0, 0, -1)))); --- my brain too ooga booga for this shit
            TT,TT2 = Camera:WorldToViewportPoint(Camera.CFrame:pointToWorldSpace(inverse))]]
			TT=math2:InverseWorldToViewportPoint(Pos*Vector3.new(0,-Size.Y/2,0))
            end
            Tracer.To = Vector2.new(TT.X,TT.Y)
            if TRACERST then Tracer.Visible = ESP else Tracer.Visible = false end
            if NT2 and NTAGST then NameTag.Visible = ESP else NameTag.Visible = false end
            if HPV2 and HESPT then HeadE.Visible = ESP else HeadE.Visible = false end
            if ARW and V5 and V6 and V7 and V8 and V9 and V10 and V11 and V12 and V13 and V14 and V15 and V16 and V17 and V18 then Arrow[1].Visible = ESP Arrow[2].Visible = ESP Arrow[3].Visible = ESP Arrow[4].Visible = ESP Arrow[5].Visible = ESP Arrow[6].Visible = ESP Arrow[7].Visible = ESP Arrow[8].Visible = ESP Arrow[9].Visible = ESP Arrow[10].Visible = ESP else Arrow[1].Visible = false Arrow[2].Visible = false Arrow[3].Visible = false Arrow[4].Visible = false Arrow[5].Visible = false Arrow[6].Visible = false Arrow[7].Visible = false Arrow[8].Visible = false Arrow[9].Visible = false Arrow[10].Visible = false end
			if HLT and V19 and V20 and V21 and V22 then Healthbar[1].Visible = ESP Healthbar[2].Visible = ESP else Healthbar[1].Visible = false Healthbar[2].Visible = false end
			if V1 and V2 and V3 and V4 then Box.Visible = ESP else Box.Visible = false end
		else NameTag.Visible = false Tracer.Visible = false HeadE.Visible = false Box.Visible = false Arrow[1].Visible = false Arrow[2].Visible = false Arrow[3].Visible = false Arrow[4].Visible = false Arrow[5].Visible = false Arrow[6].Visible = false Arrow[7].Visible = false Arrow[8].Visible = false Arrow[9].Visible = false Arrow[10].Visible = false Healthbar[1].Visible = false Healthbar[2].Visible = false end
	end
    --[[for _,waypoint in pairs(Waypoints) do
  
    end]]
end)

--[[
					local ScreenPosition, Vis = WorldToViewport(v.Instance.Position);
					local Color = v.Color;
					local OPos = Camera.CFrame:pointToObjectSpace(v.Instance.Position);
					
					if ScreenPosition.Z < 0 then
						local AT = math.atan2(OPos.Y, OPos.X) + math.pi;
						OPos = CFrame.Angles(0, 0, AT):vectorToWorldSpace((CFrame.Angles(0, math.rad(89.9), 0):vectorToWorldSpace(V3New(0, 0, -1))));
					end


]] -- This is some code yoinked from unnamed esp
---
physTPS = 0
while wait(.5) do  --- this is for a more readable stat sheet
	PINGL:UpdateLabel("Ping: "..string.split(Ping:GetValueString()," ")[1].."ms")
	FPSL:UpdateLabel("FPS: "..math2.round(1/DELTA,2)) --ez fps and rounding
	TPSL:UpdateLabel("Tasks per second: "..1/(StatsService.HeartbeatTimeMs/1000))
	PTPSL:UpdateLabel("Physics iterations per second: "..1/(StatsService.PhysicsStepTimeMs/1000))
	PhysL:UpdateLabel("Phys TPS: "..workspace:GetRealPhysicsFPS())
	PhysLR:UpdateLabel("True Phys TPS: "..tonumber(1/physTPS))
    if HALT then script:Destroy()  end
end

--GUI:MakeBox(500,500,200,100,true,0,Color3.new(255,255,255))
--[[local throwawaytable = {true,false} -- Gay ass table that i don't need
while true do
	local poop = GUI:MakeBox(math.random(0,Resolution.X),math.random(0,Resolution.Y),math.random(0,Resolution.X),math.random(0,Resolution.Y),throwawaytable[math.random(1,#throwawaytable)],math.random(0,10),Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))) -- generate random box with random properties
    wait(1)
    table.remove(GUIFRAMES,table.find(GUIFRAMES,poop))
	poop:Remove()
end]] --- Refraining from using drawing api for objects and shit. LITERALLY TOO MUCH TROUBLE FOR ITS WORTH.