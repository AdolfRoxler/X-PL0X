--GUI = loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/drawinglib.lua')()
if syn then repeat wait() until syn end
local WAITBACKGROUND = Drawing.new("Quad")
local WAITMSG = Drawing.new("Text")
local ASSETCOUNT = Drawing.new("Text")

if game:IsLoaded() then else  ---- In case game didn't load leave out a nice ass message like this
repeat game:GetService("RunService").RenderStepped:Wait() 
WAITMSG.Center = true 
WAITMSG.Visible = true
WAITMSG.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X/2,workspace.CurrentCamera.ViewportSize.Y/3)
WAITMSG.Size = workspace.CurrentCamera.ViewportSize.Y/10
WAITMSG.Text = "Yo nigga the game hasn't loaded yet"
WAITMSG.Color = Color3.new(1,1,1)
WAITMSG.OutlineColor = Color3.new(0,0,0)
WAITMSG.Outline = true
WAITMSG.Font = Drawing.Fonts["Monospace"]
WAITBACKGROUND.Visible = true
WAITBACKGROUND.PointA = Vector2.new(workspace.CurrentCamera.ViewportSize.X,0)
WAITBACKGROUND.PointB = Vector2.new(0,0)
WAITBACKGROUND.PointC = Vector2.new(0,workspace.CurrentCamera.ViewportSize.Y)
WAITBACKGROUND.PointD = Vector2.new(workspace.CurrentCamera.ViewportSize.X,workspace.CurrentCamera.ViewportSize.Y)
WAITBACKGROUND.Color = Color3.new(1,1,1)
WAITBACKGROUND.Transparency = 1
WAITBACKGROUND.Filled = true
ASSETCOUNT.Size = WAITMSG.Size*0.8
ASSETCOUNT.Position = Vector2.new(WAITMSG.Position.X,WAITMSG.Position.Y+WAITMSG.TextBounds.Y)
ASSETCOUNT.Text = "Assets to be loaded: "..game:GetService("ContentProvider").RequestQueueSize
ASSETCOUNT.OutlineColor = Color3.new(0,0,0)
ASSETCOUNT.Color = Color3.new(1,1,1)
ASSETCOUNT.Center = true
ASSETCOUNT.Visible = true
ASSETCOUNT.Outline = true
ASSETCOUNT.Font = Drawing.Fonts["Monospace"]
until game.Loaded 
end

WAITBACKGROUND:Remove()
WAITMSG:Remove()
ASSETCOUNT:Remove()

Phys = loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/physicsMANIPULATOR.lua')()
Gaylib = loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/Kavo.lua')()
math2 = loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/arbitrarymath.lua')()
User = game:GetService('Players').LocalPlayer
--- Thank you xHeptc for making the super duper sexy nigger gui lib
game:GetService("RunService").RenderStepped:connect(function() -- Constant updater to ease up resource use
    Camera = workspace.CurrentCamera
    Mouse = User:GetMouse()
    Resolution = Vector2.new(Mouse.ViewSizeX,Mouse.ViewSizeY)
end)
--- A little bit of insight, this script is the rebirth of Skidmund, a script I never released, aspiring the same objective, but in a much more efficient way.
---
--[[ Reference
local Tab= Library.CreateLib("TITLE", "DarkTheme")

local Section = Tab:NewSection("Section Name")

Section:UpdateSection("Section New Title")

Section:NewLabel("LabelText")

label:UpdateLabel("New Text")

Section:NewButton("ButtonText", "ButtonInfo", function()
    print("Clicked")
end)

button:UpdateButton("New Text")

Section:NewToggle("ToggleText", "ToggleInfo", function(state)
    if state then
        print("Toggle On")
    else
        print("Toggle Off")
    end
end)

Section:NewSlider("SliderText", "SliderInfo", 500, 0, function(s) -- 500 (MaxValue) | 0 (MinValue)
    game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = s
end)

Section:NewTextBox("TextboxText", "TextboxInfo", function(txt)
	print(txt)
end)

Section:NewKeybind("KeybindText", "KeybindInfo", Enum.KeyCode.F, function()
	print("You just clicked the bind")
end)


Library:ToggleUI()

Section:NewDropdown("DropdownText", "DropdownInf", {"Option 1", "Option 2", "Option 3"}, function(currentOption)
    print(currentOption)
end)

]]
---
--- Global Variables
ESP = false
---
local GUI = Gaylib.CreateLib("X-PL0X", "DarkTheme")
local Visuals = GUI:NewTab("Visuals")
local ESPS = Visuals:NewSection("ESP")
ESPS:NewToggle("ESP", "Toggles ESP duh", function(state)
    if state then
        ESP = true
    else
        ESP = false
    end
end)
--[[
Will be added later
local Spoofing = GUI:NewTab("Spoofing")
local Misc = GUI:NewTab("Miscellaneous")
local Prot = GUI:NewTab("Protection") 
local Util = GUI:NewTab("Utilities")
local Gim = GUI:NewTab("Gimmicks")
]]
local Settings = GUI:NewTab("Settings")
---
local Stats = GUI:NewTab("Stats")
local ClientStats = Stats:NewSection("Client")
local ServerStats = Stats:NewSection("Server")

local FPSL = ClientStats:NewLabel("FPS")
local PINGL = ClientStats:NewLabel("Ping")
local PhysL = ClientStats:NewLabel("Physics TPS")

local TPSL = ServerStats:NewLabel("TPS")
local PTPSL = ServerStats:NewLabel("Physics TPS")
---
local Credits = GUI:NewTab("Credits")
local Thx = Credits:NewSection("Thanks to:")
local Thxwho = Thx:NewLabel("Github - home of this shit")
local Thxwho2 = Thx:NewLabel("xHeptc - fuck you nigga why can't I fuck this UI???")
---
--[[  So yeah this is ESP template and stuff

[Player] = 
{
    Plr,
    Box,
    Healthbar = {},
    Arrow = {},
}

]]
--- Custom Functions and shit
PLAYERLIST = {}
lowvalue = 2^31-1
StatsService = game:GetService("Stats")
DELTA = 0
Ping = StatsService:WaitForChild("Network"):WaitForChild("ServerStatsItem"):WaitForChild("Data Ping")
function refreshplayers()
game:GetService("RunService").RenderStepped:Wait()
for _,L in pairs(PLAYERLIST) do warn(_,L) L.Box:Remove() L.Arrow[1]:Remove() L.Arrow[2]:Remove() PLAYERLIST[_]=nil end
local PlayerList = game:GetService("Players"):GetPlayers()
for _,L in pairs(PlayerList) do 
if L and L~=User then
PLAYERLIST[L]={L,Box=Drawing.new("Quad"),Arrow={Drawing.new("Quad"),Drawing.new("Triangle")}} 
end
end
end
refreshplayers() 
game:GetService("Players").PlayerAdded:connect(function() refreshplayers()  end)
game:GetService("Players").PlayerRemoving:connect(function() refreshplayers()  end)
--- Rendering section
game:GetService("RunService").RenderStepped:connect(function(D)
DELTA = D
for _,N in pairs(PLAYERLIST) do
local Plr = _
local Box = N.Box
local Arrow = N.Arrow
local Char = Plr.Character
if Char and Box and Arrow[1] and Arrow[2] then
local Pos,Size = Char:GetModelCFrame(),Char:GetExtentsSize()

local UR,V1 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X,Size.Y,0)/2))
local UL,V2 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X,Size.Y,0)/2))
local DL,V3 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X,-Size.Y,0)/2))
local DR,V4 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X,-Size.Y,0)/2))

Box.PointA = Vector2.new(UR.X,UR.Y)
Box.PointB = Vector2.new(UL.X,UL.Y)
Box.PointC = Vector2.new(DL.X,DL.Y)
Box.PointD = Vector2.new(DR.X,DR.Y)

local UR,V5 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/8,Size.Y,0)))
local UL,V6 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/8,Size.Y,0)))
local DL,V7 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/8,Size.Y,Size.X/4)))
local DR,V8 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/8,Size.Y,Size.X/4)))

Arrow[1].PointA = Vector2.new(UR.X,UR.Y)
Arrow[1].PointB = Vector2.new(UL.X,UL.Y)
Arrow[1].PointC = Vector2.new(DL.X,DL.Y)
Arrow[1].PointD = Vector2.new(DR.X,DR.Y)

local L,V9 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/4,Size.Y,0)))
local R,V10 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/4,Size.Y,0)))
local U,V11 = Camera:WorldToViewportPoint(Pos*(Vector3.new(0,Size.Y,-Size.X/4)))

Arrow[2].PointA = Vector2.new(U.X,U.Y)
Arrow[2].PointB = Vector2.new(L.X,L.Y)
Arrow[2].PointC = Vector2.new(R.X,R.Y)

--- these above are for the directional arrow
Box.Filled = false
Arrow[1].Filled = true
Arrow[2].Filled = Arrow[1].Filled

Box.Thickness = (0.068*Resolution.Y)/(Camera.CFrame.p-Pos.p).Magnitude
Box.Color = Color3.new(1,1,1)
Box.ZIndex = lowvalue

Arrow[1].Thickness = 0
Arrow[1].Color = Color3.new(1,1,1)
Arrow[1].ZIndex = Box.ZIndex+1

Arrow[2].Thickness = Arrow[1].Thickness
Arrow[2].Color = Arrow[1].Color
Arrow[2].ZIndex = Arrow[1].ZIndex



if V1 and V2 and V3 and V4 then Box.Visible = ESP else Box.Visible = false end
if V5 and V6 and V7 and V8 and V9 and V10 and V11 then Arrow[1].Visible = ESP Arrow[2].Visible = ESP else Arrow[1].Visible = false Arrow[2].Visible = false end
else Box.Visible = false Arrow[1].Visible = false Arrow[2].Visible = false end
end
end)
---
while wait(.5) do  --- this is for a more readable stat sheet
    PINGL:UpdateLabel("Ping: "..string.split(Ping:GetValueString()," ")[1].."ms")
    FPSL:UpdateLabel("FPS: "..math2.round(1/DELTA,2)) --ez fps and rounding
    TPSL:UpdateLabel("Tasks per second: "..1/(StatsService.HeartbeatTimeMs/1000))
    PTPSL:UpdateLabel("Physics iterations per second: "..1/(StatsService.PhysicsStepTimeMs/1000))
    PhysL:UpdateLabel("Physics TPS: "..workspace:GetRealPhysicsFPS())
end

--GUI:MakeBox(500,500,200,100,true,0,Color3.new(255,255,255))
--[[local throwawaytable = {true,false} -- Gay ass table that i don't need
while true do
	local poop = GUI:MakeBox(math.random(0,Resolution.X),math.random(0,Resolution.Y),math.random(0,Resolution.X),math.random(0,Resolution.Y),throwawaytable[math.random(1,#throwawaytable)],math.random(0,10),Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))) -- generate random box with random properties
    wait(1)
    table.remove(GUIFRAMES,table.find(GUIFRAMES,poop))
	poop:Remove()
end]] --- Refraining from using drawing api for objects and shit. LITERALLY TOO MUCH TROUBLE FOR ITS WORTH.