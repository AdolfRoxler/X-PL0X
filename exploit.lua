--GUI = loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/drawinglib.lua')()
if syn then repeat wait() until syn end
local WAITBACKGROUND = Drawing.new("Quad")
local WAITMSG = Drawing.new("Text")
local ASSETCOUNT = Drawing.new("Text")

if game:IsLoaded() then else  ---- In case game didn't load leave out a nice ass message like this
repeat game:GetService("RunService").RenderStepped:Wait() 
WAITMSG.Center = true 
WAITMSG.Visible = true
WAITMSG.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X/2,workspace.CurrentCamera.ViewportSize.Y/3)
WAITMSG.Size = workspace.CurrentCamera.ViewportSize.Y/10
WAITMSG.Text = "Yo nigga the game hasn't loaded yet"
WAITMSG.Color = Color3.new(1,1,1)
WAITMSG.OutlineColor = Color3.new(0,0,0)
WAITMSG.Outline = true
WAITMSG.Font = Drawing.Fonts["Monospace"]
WAITBACKGROUND.Visible = true
WAITBACKGROUND.PointA = Vector2.new(workspace.CurrentCamera.ViewportSize.X,0)
WAITBACKGROUND.PointB = Vector2.new(0,0)
WAITBACKGROUND.PointC = Vector2.new(0,workspace.CurrentCamera.ViewportSize.Y)
WAITBACKGROUND.PointD = Vector2.new(workspace.CurrentCamera.ViewportSize.X,workspace.CurrentCamera.ViewportSize.Y)
WAITBACKGROUND.Color = Color3.new(1,1,1)
WAITBACKGROUND.Transparency = 1
WAITBACKGROUND.Filled = true
ASSETCOUNT.Size = WAITMSG.Size*0.8
ASSETCOUNT.Position = Vector2.new(WAITMSG.Position.X,WAITMSG.Position.Y+WAITMSG.TextBounds.Y)
ASSETCOUNT.Text = "Assets to be loaded: "..game:GetService("ContentProvider").RequestQueueSize
ASSETCOUNT.OutlineColor = Color3.new(0,0,0)
ASSETCOUNT.Color = Color3.new(1,1,1)
ASSETCOUNT.Center = true
ASSETCOUNT.Visible = true
ASSETCOUNT.Outline = true
ASSETCOUNT.Font = Drawing.Fonts["Monospace"]
until game.Loaded 
end

WAITBACKGROUND:Remove()
WAITMSG:Remove()
ASSETCOUNT:Remove()

Phys = loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/physicsMANIPULATOR.lua')()
Gaylib = loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/Kavo.lua')()
math2 = loadstring(game:HttpGet'https://raw.githubusercontent.com/AdolfRoxler/X-PL0X/main/libraries/arbitrarymath.lua')()
User = game:GetService('Players').LocalPlayer
--- Thank you xHeptc for making the super duper sexy nigger gui lib
game:GetService("RunService").RenderStepped:connect(function() -- Constant updater to ease up resource use
    Camera = workspace.CurrentCamera
    Mouse = User:GetMouse()
    Resolution = Vector2.new(Mouse.ViewSizeX,Mouse.ViewSizeY)
end)
--- A little bit of insight, this script is the rebirth of Skidmund, a script I never released, aspiring the same objective, but in a much more efficient way.
---
--[[ Reference
local Tab= Library.CreateLib("TITLE", "DarkTheme")

local Section = Tab:NewSection("Section Name")

Section:UpdateSection("Section New Title")

Section:NewLabel("LabelText")

label:UpdateLabel("New Text")

Section:NewButton("ButtonText", "ButtonInfo", function()
    print("Clicked")
end)

button:UpdateButton("New Text")

Section:NewToggle("ToggleText", "ToggleInfo", function(state)
    if state then
        print("Toggle On")
    else
        print("Toggle Off")
    end
end)

Section:NewSlider("SliderText", "SliderInfo", 500, 0, function(s) -- 500 (MaxValue) | 0 (MinValue)
    game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = s
end)

Section:NewTextBox("TextboxText", "TextboxInfo", function(txt)
	print(txt)
end)

Section:NewKeybind("KeybindText", "KeybindInfo", Enum.KeyCode.F, function()
	print("You just clicked the bind")
end)


Library:ToggleUI()

Section:NewDropdown("DropdownText", "DropdownInf", {"Option 1", "Option 2", "Option 3"}, function(currentOption)
    print(currentOption)
end)

]]
---
--- Global Variables
ESP = false
---
local GUI = Gaylib.CreateLib("X-PL0X", "DarkTheme")
local Visuals = GUI:NewTab("Visuals")
local ESPS = Visuals:NewSection("ESP")
ESPS:NewToggle("ESP", "Toggles ESP duh", function(state)
    if state then
        ESP = true
    else
        ESP = false
    end
end)

--[[
Will be added later
local Spoofing = GUI:NewTab("Spoofing")
local Misc = GUI:NewTab("Miscellaneous")
local Prot = GUI:NewTab("Protection") 
local Util = GUI:NewTab("Utilities")
local Gim = GUI:NewTab("Gimmicks")
]]
---
local Stats = GUI:NewTab("Stats")
local ClientStats = Stats:NewSection("Client")
local ServerStats = Stats:NewSection("Server")

local FPSL = ClientStats:NewLabel("FPS")
local PINGL = ClientStats:NewLabel("Ping")
local PhysL = ClientStats:NewLabel("Physics TPS")

local TPSL = ServerStats:NewLabel("TPS")
local PTPSL = ServerStats:NewLabel("Physics TPS")
---
local Settings = GUI:NewTab("Settings")
local ESPSETBANNER = Settings:NewSection("ESP")
---
local Credits = GUI:NewTab("Credits")
local Thx = Credits:NewSection("Thanks to:")
local Thxwho = Thx:NewLabel("Github - home of this shit")
local Thxwho2 = Thx:NewLabel("xHeptc - fuck you nigga why can't I fuck this UI???")
---
--[[  So yeah this is ESP template and stuff

[Player] = 
{
    Plr,
    Box,
    Healthbar = {},
    Arrow = {},
}

]]
--- Custom Functions and shit
PLAYERLIST = {}
lowvalue = 2^31-1
highvalue = -lowvalue
StatsService = game:GetService("Stats")
DELTA = 0
Ping = StatsService:WaitForChild("Network"):WaitForChild("ServerStatsItem"):WaitForChild("Data Ping")
function refreshplayers()
game:GetService("RunService").RenderStepped:Wait()
for _,L in pairs(PLAYERLIST) do L.Healthbar[1]:Remove() L.Healthbar[2]:Remove() L.Box:Remove() L.Arrow[1]:Remove() L.Arrow[2]:Remove() L.Arrow[3]:Remove() L.Arrow[4]:Remove() L.Arrow[5]:Remove() L.Arrow[6]:Remove() L.Arrow[7]:Remove() L.Arrow[8]:Remove() L.Arrow[9]:Remove() L.Arrow[10]:Remove() PLAYERLIST[_]=nil end
local PlayerList = game:GetService("Players"):GetPlayers()
for _,L in pairs(PlayerList) do 
if L and L~=User then
PLAYERLIST[L]={L,Box=Drawing.new("Quad"),Healthbar={Drawing.new("Quad"),Drawing.new("Quad")},Arrow={Drawing.new("Quad"),Drawing.new("Triangle"),Drawing.new("Quad"),Drawing.new("Triangle"),Drawing.new("Quad"),Drawing.new("Quad"),Drawing.new("Quad"),Drawing.new("Quad"),Drawing.new("Quad"),Drawing.new("Quad")}} 
end
end
end
refreshplayers() 
game:GetService("Players").PlayerAdded:connect(function() refreshplayers()  end)
game:GetService("Players").PlayerRemoving:connect(function() refreshplayers()  end)
--- Rendering section
game:GetService("RunService").RenderStepped:connect(function(D)
DELTA = D
for _,N in pairs(PLAYERLIST) do
local Plr = _
local Box = N.Box
local Arrow = N.Arrow
local Healthbar = N.Healthbar
local Char = Plr.Character
if Char and Box and Arrow[10] and Healthbar[2] then
local Hum = Char:FindFirstChildOfClass("Humanoid")
local Pos,Size = Char:GetModelCFrame(),Char:GetExtentsSize()

local UR,V1 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X,Size.Y,0)/2))
local UL,V2 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X,Size.Y,0)/2))
local DL,V3 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X,-Size.Y,0)/2))
local DR,V4 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X,-Size.Y,0)/2))

Box.PointA = Vector2.new(UR.X,UR.Y)
Box.PointB = Vector2.new(UL.X,UL.Y)
Box.PointC = Vector2.new(DL.X,DL.Y)
Box.PointD = Vector2.new(DR.X,DR.Y)

local UR,V5 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/8,Size.Y,0)))
local UL,V6 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/8,Size.Y,0)))
local DL,V7 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/8,Size.Y,Size.X/2)))
local DR,V8 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/8,Size.Y,Size.X/2)))

Arrow[1].PointA = Vector2.new(UR.X,UR.Y)
Arrow[1].PointB = Vector2.new(UL.X,UL.Y)
Arrow[1].PointC = Vector2.new(DL.X,DL.Y)
Arrow[1].PointD = Vector2.new(DR.X,DR.Y)

local L,V9 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/4,Size.Y,0)))
local R,V10 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/4,Size.Y,0)))
local U,V11 = Camera:WorldToViewportPoint(Pos*(Vector3.new(0,Size.Y,-Size.X/2)))

Arrow[2].PointA = Vector2.new(U.X,U.Y)
Arrow[2].PointB = Vector2.new(L.X,L.Y)
Arrow[2].PointC = Vector2.new(R.X,R.Y)

local UR2,V12 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/8,Size.Y+Size.X/5,0)))
local UL2,V13 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/8,Size.Y+Size.X/5,0)))
local DL2,V14 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/8,Size.Y+Size.X/5,Size.X/2)))
local DR2,V15 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/8,Size.Y+Size.X/5,Size.X/2)))

Arrow[3].PointA = Vector2.new(UR2.X,UR2.Y)
Arrow[3].PointB = Vector2.new(UL2.X,UL2.Y)
Arrow[3].PointC = Vector2.new(DL2.X,DL2.Y)
Arrow[3].PointD = Vector2.new(DR2.X,DR2.Y)

local L2,V16 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/4,Size.Y+Size.X/5,0)))
local R2,V17 = Camera:WorldToViewportPoint(Pos*(Vector3.new(Size.X/4,Size.Y+Size.X/5,0)))
local U2,V18 = Camera:WorldToViewportPoint(Pos*(Vector3.new(0,Size.Y+Size.X/5,-Size.X/2)))

Arrow[4].PointA = Vector2.new(U2.X,U2.Y)
Arrow[4].PointB = Vector2.new(L2.X,L2.Y)
Arrow[4].PointC = Vector2.new(R2.X,R2.Y)

--- these above are for the directional arrow



local BUR,V19 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/1.65,Size.Y/2,0)))
local BUL,V20 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/2,Size.Y/2,0)))
local BDL,V21 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/2,-Size.Y/2,0)))
local BDR,V22 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/1.65,-Size.Y/2,0)))

local H1,H2 = 0,0

if Hum then
local healthperone = (Hum.Health/Hum.MaxHealth)
--if Hum.Health==0 or Hum:GetState() == Enum.HumanoidStateType.Dead then healthperone=0 end
H1 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/1.65,(Size.Y/2)*healthperone,0)))
H2 = Camera:WorldToViewportPoint(Pos*(Vector3.new(-Size.X/2,(Size.Y/2)*healthperone,0)))
Healthbar[2].Color = Color3.fromRGB(232,39,15):lerp(Color3.fromRGB(27, 252, 107),healthperone)
else
H1 = BDL
H2 = BDR
end

Healthbar[1].PointA = Vector2.new(BUR.X,BUR.Y)
Healthbar[1].PointB = Vector2.new(BUL.X,BUL.Y)
Healthbar[1].PointC = Vector2.new(BDL.X,BDL.Y)
Healthbar[1].PointD = Vector2.new(BDR.X,BDR.Y)

Healthbar[2].PointA = Vector2.new(H1.X,H1.Y)
Healthbar[2].PointB = Vector2.new(H2.X,H2.Y)
Healthbar[2].PointC = Vector2.new(BDL.X,BDL.Y)
Healthbar[2].PointD = Vector2.new(BDR.X,BDR.Y)

--- healthbar logic above


Box.Filled = false
Arrow[1].Filled = true
Arrow[2].Filled = Arrow[1].Filled
Arrow[3].Filled = Arrow[1].Filled
Arrow[4].Filled = Arrow[1].Filled
Arrow[5].Filled = Arrow[1].Filled
Arrow[6].Filled = Arrow[1].Filled
Arrow[7].Filled = Arrow[1].Filled
Arrow[8].Filled = Arrow[1].Filled
Arrow[9].Filled = Arrow[1].Filled
Arrow[10].Filled = Arrow[1].Filled

Arrow[1].Transparency = 0.25
Arrow[2].Transparency = Arrow[1].Transparency
Arrow[3].Transparency = Arrow[1].Transparency
Arrow[4].Transparency = Arrow[1].Transparency
Arrow[5].Transparency = Arrow[1].Transparency
Arrow[6].Transparency = Arrow[1].Transparency
Arrow[7].Transparency = Arrow[1].Transparency
Arrow[8].Transparency = Arrow[1].Transparency
Arrow[9].Transparency = Arrow[1].Transparency
Arrow[10].Transparency = Arrow[1].Transparency

Box.Thickness = (0.068*Resolution.Y)/(Camera.CFrame.p-(Pos.p+Vector3.new(0,Size.Y,0))).Magnitude
Box.Color = Color3.new(1,1,1)
Box.ZIndex = lowvalue



Healthbar[1].Filled = true
Healthbar[1].ZIndex = lowvalue+1
Healthbar[1].Color = Color3.new(0,0,0)
Healthbar[1].Thickness = 0--Box.Thickness

Healthbar[2].Filled = true
Healthbar[2].ZIndex = Healthbar[1].ZIndex+1
Healthbar[2].Thickness = 0


Arrow[1].Thickness = 0 --(0.06*Resolution.Y)/(Camera.CFrame.p-(Pos.p+Vector3.new(0,Size.Y,0))).Magnitude
Arrow[1].Color = Plr.TeamColor.Color
Arrow[1].ZIndex = Box.ZIndex+3

Arrow[2].Thickness = Arrow[1].Thickness*2
Arrow[2].Color = Arrow[1].Color
Arrow[2].ZIndex = Arrow[1].ZIndex

Arrow[3].Thickness = Arrow[1].Thickness
Arrow[3].Color = Arrow[1].Color
Arrow[3].ZIndex = Arrow[1].ZIndex

Arrow[4].Thickness = Arrow[1].Thickness*2
Arrow[4].Color = Arrow[1].Color
Arrow[4].ZIndex = Arrow[1].ZIndex

Arrow[5].Thickness = Arrow[1].Thickness
Arrow[5].Color = Arrow[1].Color
Arrow[5].ZIndex = Arrow[1].ZIndex
Arrow[5].PointA = Vector2.new(U2.X,U2.Y)
Arrow[5].PointB = Vector2.new(R2.X,R2.Y)
Arrow[5].PointC = Vector2.new(R.X,R.Y)
Arrow[5].PointD = Vector2.new(U.X,U.Y)

Arrow[6].Thickness = Arrow[1].Thickness
Arrow[6].Color = Arrow[1].Color
Arrow[6].ZIndex = Arrow[1].ZIndex
Arrow[6].PointA = Vector2.new(U2.X,U2.Y)
Arrow[6].PointB = Vector2.new(L2.X,L2.Y)
Arrow[6].PointC = Vector2.new(L.X,L.Y)
Arrow[6].PointD = Vector2.new(U.X,U.Y)

Arrow[7].Thickness = Arrow[1].Thickness
Arrow[7].Color = Arrow[1].Color
Arrow[7].ZIndex = Arrow[1].ZIndex
Arrow[7].PointA = Vector2.new(R2.X,R2.Y)
Arrow[7].PointB = Vector2.new(L2.X,L2.Y)
Arrow[7].PointC = Vector2.new(L.X,L.Y)
Arrow[7].PointD = Vector2.new(R.X,R.Y)

Arrow[8].Thickness = Arrow[1].Thickness
Arrow[8].Color = Arrow[1].Color
Arrow[8].ZIndex = Arrow[1].ZIndex
Arrow[8].PointA = Vector2.new(UR2.X,UR2.Y)
Arrow[8].PointB = Vector2.new(DR2.X,DR2.Y)
Arrow[8].PointC = Vector2.new(DR.X,DR.Y)
Arrow[8].PointD = Vector2.new(UR.X,UR.Y)

Arrow[9].Thickness = Arrow[1].Thickness
Arrow[9].Color = Arrow[1].Color
Arrow[9].ZIndex = Arrow[1].ZIndex
Arrow[9].PointA = Vector2.new(UL2.X,UL2.Y)
Arrow[9].PointB = Vector2.new(DL2.X,DL2.Y)
Arrow[9].PointC = Vector2.new(DL.X,DL.Y)
Arrow[9].PointD = Vector2.new(UL.X,UL.Y)

Arrow[10].Thickness = Arrow[1].Thickness
Arrow[10].Color = Arrow[1].Color
Arrow[10].ZIndex = Arrow[1].ZIndex
Arrow[10].PointA = Vector2.new(DR2.X,DR2.Y)
Arrow[10].PointB = Vector2.new(DL2.X,DL2.Y)
Arrow[10].PointC = Vector2.new(DL.X,DL.Y)
Arrow[10].PointD = Vector2.new(DR.X,DR.Y)

if V19 and V20 and V21 and V22 then Healthbar[1].Visible = ESP Healthbar[2].Visible = ESP else Healthbar[1].Visible = false Healthbar[2].Visible = false end
if V1 and V2 and V3 and V4 then Box.Visible = ESP else Box.Visible = false end
if V5 and V6 and V7 and V8 and V9 and V10 and V11 and V12 and V13 and V14 and V15 and V16 and V17 and V18 then Arrow[1].Visible = ESP Arrow[2].Visible = ESP Arrow[3].Visible = ESP Arrow[4].Visible = ESP Arrow[5].Visible = ESP Arrow[6].Visible = ESP Arrow[7].Visible = ESP Arrow[8].Visible = ESP Arrow[9].Visible = ESP Arrow[10].Visible = ESP else Arrow[1].Visible = false Arrow[2].Visible = false Arrow[3].Visible = false Arrow[4].Visible = false Arrow[5].Visible = false Arrow[6].Visible = false Arrow[7].Visible = false Arrow[8].Visible = false Arrow[9].Visible = false Arrow[10].Visible = false end
else Box.Visible = false Arrow[1].Visible = false Arrow[2].Visible = false Arrow[3].Visible = false Arrow[4].Visible = false Arrow[5].Visible = false Arrow[6].Visible = false Arrow[7].Visible = false Arrow[8].Visible = false Arrow[9].Visible = false Arrow[10].Visible = false end
end
end)
---
while wait(.5) do  --- this is for a more readable stat sheet
    PINGL:UpdateLabel("Ping: "..string.split(Ping:GetValueString()," ")[1].."ms")
    FPSL:UpdateLabel("FPS: "..math2.round(1/DELTA,2)) --ez fps and rounding
    TPSL:UpdateLabel("Tasks per second: "..1/(StatsService.HeartbeatTimeMs/1000))
    PTPSL:UpdateLabel("Physics iterations per second: "..1/(StatsService.PhysicsStepTimeMs/1000))
    PhysL:UpdateLabel("Physics TPS: "..workspace:GetRealPhysicsFPS())
end

--GUI:MakeBox(500,500,200,100,true,0,Color3.new(255,255,255))
--[[local throwawaytable = {true,false} -- Gay ass table that i don't need
while true do
	local poop = GUI:MakeBox(math.random(0,Resolution.X),math.random(0,Resolution.Y),math.random(0,Resolution.X),math.random(0,Resolution.Y),throwawaytable[math.random(1,#throwawaytable)],math.random(0,10),Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))) -- generate random box with random properties
    wait(1)
    table.remove(GUIFRAMES,table.find(GUIFRAMES,poop))
	poop:Remove()
end]] --- Refraining from using drawing api for objects and shit. LITERALLY TOO MUCH TROUBLE FOR ITS WORTH.